<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <meta name="color-scheme" content="light dark" />
    <title>Chematek Hero — Bonds + Pin</title>
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin />
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
        margin: 0;
      }
      body {
        background: #0a2746;
        color: #e8eef6;
        font-family: system-ui, Arial, sans-serif;
      }
      :root {
        --vh: 1vh;
      }
      #hero {
        position: relative;
        width: 100%;
        height: 100dvh;
        height: calc(var(--vh) * 100);
        overflow: hidden;
        overscroll-behavior: contain;
        background: radial-gradient(
          120% 120% at 30% 20%,
          #0161ae 0%,
          #06223d 60%,
          #002c50 100%
        );
      }
      #hero canvas {
        display: block;
        width: 100%;
        height: 100%;
      }
      .poster {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        filter: saturate(0.9) brightness(1.05);
      }
      .poster.hidden {
        display: none;
      }
      .status {
        position: absolute;
        inset: auto 0 1rem 0;
        text-align: center;
        font-size: 0.9rem;
        opacity: 0.7;
        pointer-events: none;
      }
      .copy {
        position: absolute;
        max-width: 44ch;
        line-height: 1.1;
        letter-spacing: 0.02em;
        text-wrap: balance;
      }
      #copy1 {
        left: 4vw;
        top: 22vh;
        font-weight: 500;
        font-size: clamp(30px, 5vw, 60px);
        color: #e9eef6;
      }
      #copy2 {
        right: 5vw;
        top: 80vh;
        font-weight: 400;
        font-size: clamp(18px, 1.6vw, 24px);
        color: #d9e3ef;
        opacity: 0;
        pointer-events: none;
      }

      #after {
        min-height: 200vh;
        display: grid;
        place-items: center;
        background: linear-gradient(180deg, #051c33 0%, #0b0a46 100%);
      }
    </style>
  </head>
  <body>
    <section id="hero" aria-label="Hero 3D stage">
      <img
        class="poster"
        alt="Molecule hero poster"
        src="data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1200' height='800'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop stop-color='%230e3969'/%3E%3Cstop offset='1' stop-color='%23051c33'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect fill='url(%23g)' width='1200' height='800'/%3E%3C/svg%3E"
      />
      <div class="status" id="status">Bonds + Pin setup…</div>
      <div id="copy1" class="copy">
        / IN THE<br />PURSUIT OF<br />
        <span style="color: #f89a5f"> PROGRESS</span>
      </div>
      <div id="copy2" class="copy">
        Chematek is an industrial technology company that offers products,
        services, and solutions for chemicals, lubricants and engineering,
        procurement, and construction.
      </div>
    </section>
    <section id="after">
      <div>Scroll past the pinned hero to verify release behavior.</div>
    </section>

    <script src="./assets/vendor/gsap.min.js"></script>
    <script src="./assets/vendor/ScrollTrigger.min.js"></script>
    <script>
      if (window.gsap && window.ScrollTrigger) {
        gsap.registerPlugin(ScrollTrigger);
      }
    </script>
    <script type="module">
      import * as THREE from "./assets/vendor/three.module.min.js";

      // Constants - moved to top for better organization
      const CONFIG = {
        CAP_VIS_EPS: 0.03,
        CAP_SHRINK_IN: 0.08,
        CAP_SHRINK_OUT: 0.18,
        CAP_SCALE: 1.06,
        BASE_RADIUS: 0.5,
        BOND_RADIUS: 0.14,
        RING_RADIUS: 2.9,
        TARGET_RADIUS: 1.8,
        BULGE_RATIO: 0.35,
        LUT_SAMPLES: 240, // Reduced from 320 for performance
        BASE_COLOR: 0x1c1a70,
      };

      // Cached reusable objects
      const tempVectors = {
        v1: new THREE.Vector3(),
        v2: new THREE.Vector3(),
        v3: new THREE.Vector3(),
        dir: new THREE.Vector3(),
        dirN: new THREE.Vector3(),
        tmpNeg: new THREE.Vector3(),
        tmpCw: new THREE.Vector3(),
        tmpOw: new THREE.Vector3(),
        tmpCl: new THREE.Vector3(),
        tmpOl: new THREE.Vector3(),
      };

      const UP = new THREE.Vector3(0, 1, 0);

      // Mobile viewport stability
      (function setVH() {
        const set = () =>
          document.documentElement.style.setProperty(
            "--vh",
            window.innerHeight * 0.01 + "px"
          );
        set();
        addEventListener("resize", set, { passive: true });
        addEventListener("orientationchange", set);
      })();

      const heroEl = document.getElementById("hero");
      const statusEl = document.getElementById("status");
      const posterEl = document.querySelector(".poster");

      let renderer, scene, camera, molecule, rafId;
      let bonds = [];
      let atoms = [];
      let center;

      // Geometry cache
      let atomGeo, halfGeo, capGeo;

      // Material cache
      let atomMat, bondMat;

      try {
        // Renderer setup
        renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: false,
          powerPreference: "high-performance",
        });

        const isCoarse = matchMedia("(pointer: coarse)").matches;
        const dprCap = isCoarse ? 1.75 : 2.0;
        renderer.setPixelRatio(Math.min(devicePixelRatio || 1, dprCap));
        renderer.setSize(heroEl.clientWidth, heroEl.clientHeight, false);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        renderer.physicallyCorrectLights = true;
        renderer.sortObjects = true;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.setClearColor(0x000000, 0);
        heroEl.prepend(renderer.domElement);

        // Camera positioning function
        function updateCameraForViewport() {
          const w = window.innerWidth;
          let z = 8.0;
          if (w <= 1280) z = 8.4;
          if (w <= 900) z = 8.8;
          if (w <= 600) z = 9.2;
          if (w <= 420) z = 9.6;
          camera.position.z = z;
          camera.updateProjectionMatrix();
        }

        // Scene setup
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          35,
          heroEl.clientWidth / heroEl.clientHeight,
          0.1,
          100
        );
        camera.position.set(0, 0, 8);

        // Lighting setup
        const key = new THREE.DirectionalLight(0xffffff, 1.05);
        key.position.set(2.2, 3.0, 4.0);
        const rim = new THREE.DirectionalLight(0xaecbff, 0.38);
        rim.position.set(-3.0, 1.2, -2.2);
        const amb = new THREE.AmbientLight(0xffffff, 0.18);
        scene.add(key, rim, amb);

        // Environment setup
        const pmrem = new THREE.PMREMGenerator(renderer);
        pmrem.compileEquirectangularShader();

        const envScene = new THREE.Scene();
        const room = new THREE.Mesh(
          new THREE.BoxGeometry(10, 10, 10),
          new THREE.MeshBasicMaterial({ color: 0x0a2746, side: THREE.BackSide })
        );
        envScene.add(room);

        // Environment panels
        const panelMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const panelConfigs = [
          [-2.2, 2.1, -3.0, 0.0, 0.0, 3.0, 2.0, 3.0],
          [3.0, -1.0, 2.2, 0.0, Math.PI / 2, 2.0, 1.5, 2.4],
          [-3.2, -2.0, 1.0, 0.0, -Math.PI / 2, 1.4, 2.4, 2.1],
        ];

        panelConfigs.forEach(([x, y, z, rx, ry, w, h, luminance]) => {
          const m = new THREE.Mesh(
            new THREE.PlaneGeometry(w, h),
            panelMaterial.clone()
          );
          m.position.set(x, y, z);
          m.rotation.set(rx, ry, 0);
          m.material.color.setScalar(luminance);
          envScene.add(m);
        });

        const envRT = pmrem.fromScene(envScene, 0.04);
        scene.environment = envRT.texture;

        // Material setup
        atomMat = new THREE.MeshPhysicalMaterial({
          color: CONFIG.BASE_COLOR,
          roughness: 0.08,
          metalness: 0.0,
          clearcoat: 1.0,
          clearcoatRoughness: 0.06,
          transmission: 0.9,
          ior: 1.333,
          thickness: 0.4,
          attenuationColor: new THREE.Color(CONFIG.BASE_COLOR),
          attenuationDistance: 1.6,
          envMapIntensity: 1.25,
          opacity: 1.0,
          transparent: true,
        });

        bondMat = atomMat.clone();
        bondMat.transmission = 0.82;
        bondMat.thickness = 0.34;
        bondMat.envMapIntensity = 1.15;

        // Geometry setup - create once and reuse
        atomGeo = new THREE.SphereGeometry(CONFIG.BASE_RADIUS, 48, 48);
        halfGeo = new THREE.CylinderGeometry(
          CONFIG.BOND_RADIUS,
          CONFIG.BOND_RADIUS,
          1,
          24
        );
        halfGeo.translate(0, 0.5, 0);
        capGeo = new THREE.SphereGeometry(CONFIG.BOND_RADIUS * 1.15, 24, 18);

        // Molecule structure
        molecule = new THREE.Group();
        scene.add(molecule);

        const masterSurface = new THREE.Group();
        molecule.add(masterSurface);

        const centerGroup = new THREE.Group();
        const ringGroup = new THREE.Group();
        masterSurface.add(centerGroup, ringGroup);
        masterSurface.rotation.set(Math.PI / 1.5, -0.2, 0.0);

        // Central atom
        center = new THREE.Mesh(atomGeo, atomMat);
        center.position.set(0, 0, 0);
        center.scale.setScalar(1);
        centerGroup.add(center);
        center.renderOrder = 0;

        // Outer atoms positions
        const baseAngle = Math.PI / 2;
        const step = (2 * Math.PI) / 5;

        const startRing = Array.from({ length: 5 }, (_, i) => {
          const ang = baseAngle - i * step;
          return new THREE.Vector3(
            Math.cos(ang) * CONFIG.RING_RADIUS,
            Math.sin(ang) * CONFIG.RING_RADIUS,
            0
          );
        });

        // Create atoms
        atoms = Array.from({ length: 5 }, (_, i) => {
          const m = new THREE.Mesh(atomGeo, atomMat);
          m.position.copy(startRing[i]);
          m.scale.setScalar(1.2 + Math.random() * 0.45);
          ringGroup.add(m);
          m.renderOrder = 2;
          return m;
        });

        const startPositions = atoms.map((m) => m.position.clone());

        // Target positions
        const R = CONFIG.TARGET_RADIUS;
        const targets = [
          new THREE.Vector3(0.0, 0.0, R),
          new THREE.Vector3(0.0, 0.0, -R),
          new THREE.Vector3(0.0, R, 0.0),
          new THREE.Vector3(
            R * Math.cos(-Math.PI / 6),
            R * Math.sin(-Math.PI / 6),
            0.0
          ),
          new THREE.Vector3(
            R * Math.cos((7 * Math.PI) / 6),
            R * Math.sin((7 * Math.PI) / 6),
            0.0
          ),
        ];

        // Optimized elliptical via calculation
        function createEllipticalVia(
          startPos,
          targetPos,
          centerPos = new THREE.Vector3(0, 0, 0)
        ) {
          const { v1: toStart, v2: toTarget, v3: midpoint } = tempVectors;

          toStart.subVectors(startPos, centerPos);
          toTarget.subVectors(targetPos, centerPos);
          midpoint.addVectors(startPos, targetPos).multiplyScalar(0.5);

          const chord = tempVectors.dir.subVectors(targetPos, startPos);
          const chordLength = chord.length();

          const orbitalNormal = toStart.clone().cross(toTarget).normalize();
          if (orbitalNormal.length() < 0.001) {
            orbitalNormal.set(0, 0, 1);
          }

          let bulgeDirection = orbitalNormal.clone().cross(chord).normalize();
          const midToCenter = tempVectors.v1.subVectors(centerPos, midpoint);
          if (bulgeDirection.dot(midToCenter) > 0) {
            bulgeDirection.multiplyScalar(-1);
          }

          const bulgeAmount = chordLength * CONFIG.BULGE_RATIO;
          return midpoint
            .clone()
            .add(bulgeDirection.multiplyScalar(bulgeAmount));
        }

        const centerWorldPos = new THREE.Vector3(0, 0, 0);
        const vias = atoms.map((_, i) =>
          createEllipticalVia(startPositions[i], targets[i], centerWorldPos)
        );

        // Optimized Bezier LUT with reduced samples
        function buildSmoothBezierLUT(
          p0,
          p1,
          p2,
          samples = CONFIG.LUT_SAMPLES
        ) {
          const pts = new Array(samples + 1);
          const len = new Float32Array(samples + 1);
          let acc = 0;

          for (let i = 0; i <= samples; i++) {
            let t = i / samples;
            t = t < 0.5 ? 2 * t * t : 1 - 2 * (1 - t) * (1 - t);

            const it = 1 - t;
            const x = it * it * p0.x + 2 * it * t * p1.x + t * t * p2.x;
            const y = it * it * p0.y + 2 * it * t * p1.y + t * t * p2.y;
            const z = it * it * p0.z + 2 * it * t * p1.z + t * t * p2.z;

            pts[i] = new THREE.Vector3(x, y, z);
            if (i > 0) {
              acc += pts[i].distanceTo(pts[i - 1]);
            }
            len[i] = acc;
          }

          return { pts, len, total: acc };
        }

        function tFromS(lut, s) {
          const target = s * lut.total;
          let lo = 0,
            hi = lut.len.length - 1;
          while (lo < hi) {
            const mid = (lo + hi) >> 1;
            lut.len[mid] < target ? (lo = mid + 1) : (hi = mid);
          }
          const i = Math.max(1, lo);
          const l0 = lut.len[i - 1],
            l1 = lut.len[i];
          const f = (target - l0) / Math.max(1e-6, l1 - l0);
          return (i - 1 + f) / (lut.len.length - 1);
        }

        function moveAlongSmoothQuadratic(atomIdx, p0, p1, p2, tl, dur, at) {
          const lut = buildSmoothBezierLUT(p0, p1, p2);
          const proxy = { s: 0 };

          tl.to(
            proxy,
            {
              s: 1,
              duration: dur,
              ease: "power1.inOut",
              onUpdate: () => {
                const t = tFromS(lut, proxy.s);
                const it = 1 - t;
                const x = it * it * p0.x + 2 * it * t * p1.x + t * t * p2.x;
                const y = it * it * p0.y + 2 * it * t * p1.y + t * t * p2.y;
                const z = it * it * p0.z + 2 * it * t * p1.z + t * t * p2.z;
                atoms[atomIdx].position.set(x, y, z);
              },
            },
            at
          );
        }

        // Bond creation
        function createCenterBond(outerIdx) {
          const aHalf = new THREE.Mesh(halfGeo, bondMat);
          const bHalf = new THREE.Mesh(halfGeo, bondMat);
          aHalf.visible = bHalf.visible = false;
          molecule.add(aHalf, bHalf);
          aHalf.renderOrder = 1;
          bHalf.renderOrder = 1;

          const capC = new THREE.Mesh(capGeo, bondMat);
          const capO = new THREE.Mesh(capGeo, bondMat);
          capC.visible = capO.visible = false;
          molecule.add(capC, capO);
          capC.renderOrder = 1;
          capO.renderOrder = 1;

          const pair = {
            a: aHalf,
            b: bHalf,
            capA: capC,
            capB: capO,
            growth: 0,
            outerIdx,
            oneSided: true,
          };
          bonds.push(pair);
          return pair;
        }

        // Create bonds
        for (let i = 0; i < 5; i++) {
          createCenterBond(i);
        }

        // Optimized bond positioning
        function positionCenterBond(pair) {
          const {
            tmpCw,
            tmpOw,
            tmpCl,
            tmpOl,
            dir,
            dirN,
            v1: tmpV1,
            v2: tmpV2,
            tmpNeg,
          } = tempVectors;

          center.getWorldPosition(tmpCw);
          atoms[pair.outerIdx].getWorldPosition(tmpOw);

          tmpCl.copy(tmpCw);
          molecule.worldToLocal(tmpCl);
          tmpOl.copy(tmpOw);
          molecule.worldToLocal(tmpOl);

          dir.subVectors(tmpOl, tmpCl);
          const centerDist = dir.length();
          const g = pair.growth;
          const show = g > CONFIG.CAP_VIS_EPS;

          const t = Math.min(
            Math.max(
              (g - CONFIG.CAP_SHRINK_IN) /
                (CONFIG.CAP_SHRINK_OUT - CONFIG.CAP_SHRINK_IN),
              0
            ),
            1
          );
          const s = CONFIG.CAP_SCALE * t;
          pair.capA.scale.setScalar(s);
          pair.capB.scale.setScalar(s);

          const rC = CONFIG.BASE_RADIUS * center.scale.x;
          const rO = CONFIG.BASE_RADIUS * atoms[pair.outerIdx].scale.x;
          const coreLen = Math.max(0, centerDist - (rC + rO));
          const len = coreLen * g;
          const visible = show && len > 1e-6;

          dirN.copy(dir).normalize();

          // One-sided growth optimization
          pair.a.visible = false;
          pair.b.visible = visible;

          if (visible) {
            pair.b.position
              .copy(tmpOl)
              .add(tmpV2.copy(dirN).multiplyScalar(-rO));
            tmpNeg.copy(dirN).multiplyScalar(-1);
            pair.b.quaternion.setFromUnitVectors(UP, tmpNeg);
            pair.b.scale.set(1, len, 1);
          }

          const showCapOuter = g > 0.001;
          const showCapCenter = g > 0.95;

          pair.capB.visible = showCapOuter;
          if (showCapOuter) {
            pair.capB.position
              .copy(tmpOl)
              .add(tmpV2.copy(dirN).multiplyScalar(-rO));
            pair.capB.scale.setScalar(s);
          }

          pair.capA.visible = showCapCenter;
          if (showCapCenter) {
            pair.capA.position
              .copy(tmpCl)
              .add(tmpV1.copy(dirN).multiplyScalar(rC));
            pair.capA.scale.setScalar(CONFIG.CAP_SCALE);
          }
        }

        // Enhanced render loop with continuous motion
        let time = 0;
        let isScrollComplete = false;
        let isFinalized = false;
        let enableFinalMotion = false;
        let finalBlend = 0;

        function render() {
          time += 0.008; // Control speed of continuous motion

          // Apply continuous motion only after scroll animation completes
          if (enableFinalMotion || finalBlend > 0) {
            const spinMix = enableFinalMotion ? 1 : finalBlend;

            // additive, so it won't fight GSAP's masterSurface rotation
            molecule.rotation.y += 0.0025 * spinMix;
            molecule.rotation.x += Math.sin(time * 0.8) * 0.0012 * spinMix;
            molecule.rotation.z += Math.cos(time * 0.6) * 0.0008 * spinMix;

            // breathing (kept as-is)
            atoms.forEach((atom, i) => {
              const offset = i * 0.8;
              const vibration = Math.sin(time * 1.2 + offset) * 0.002 * spinMix;
              const baseScale = atom.userData.baseScale || atom.scale.x;
              atom.scale.setScalar(baseScale + vibration);
            });
            const centerBreathing = Math.sin(time * 0.9) * 0.003 * spinMix;
            const centerBaseScale = center.userData.baseScale || center.scale.x;
            center.scale.setScalar(centerBaseScale + centerBreathing);
          }

          scene.updateMatrixWorld(true);
          bonds.forEach(positionCenterBond);
          renderer.render(scene, camera);
          rafId = requestAnimationFrame(render);
        }
        rafId = requestAnimationFrame(render);

        // Resize handling
        let resizeRAF;
        const onResize = () => {
          const rect = heroEl.getBoundingClientRect();
          const w = Math.max(1, Math.floor(rect.width));
          const h = Math.max(1, Math.floor(rect.height));

          const isCoarse = matchMedia("(pointer: coarse)").matches;
          const dprCap = isCoarse ? 1.75 : 2.0;
          const nextDpr = Math.min(window.devicePixelRatio || 1, dprCap);
          if (renderer.getPixelRatio() !== nextDpr) {
            renderer.setPixelRatio(nextDpr);
          }

          camera.aspect = w / h;
          camera.updateProjectionMatrix();
          renderer.setSize(w, h, false);
          updateCameraForViewport();

          if (window.ScrollTrigger) {
            cancelAnimationFrame(resizeRAF);
            resizeRAF = requestAnimationFrame(() => ScrollTrigger.refresh());
          }
        };

        addEventListener("resize", onResize, { passive: true });
        addEventListener("orientationchange", onResize);
        addEventListener(
          "pageshow",
          (e) => {
            if (e.persisted) onResize();
          },
          { passive: true }
        );
        onResize();

        // GSAP Timeline
        if (window.gsap && window.ScrollTrigger) {
          const PREFERS_REDUCED = window.matchMedia(
            "(prefers-reduced-motion: reduce)"
          ).matches;

          updateCameraForViewport();

          function finalizeStatic() {
            atoms.forEach((m, i) => {
              m.position.copy(targets[i]);
              // Store base scale for breathing animation
              m.userData.baseScale = m.scale.x;
            });
            bonds.forEach((pair) => {
              pair.growth = 1;
              if (pair.a) pair.a.visible = false;
              if (pair.b) pair.b.visible = true;
              if (pair.capA) pair.capA.visible = true;
              if (pair.capB) pair.capB.visible = true;
              positionCenterBond(pair);
            });

            // Store final rotation and enable continuous motion
            masterSurface.userData.finalRotation = {
              x: masterSurface.rotation.x,
              y: masterSurface.rotation.y,
              z: masterSurface.rotation.z,
            };
            center.userData.baseScale = center.scale.x;
            isScrollComplete = true;

            renderer.render(scene, camera);
            gsap.set("#copy1", { opacity: 0, y: -10 });
            gsap.set("#copy2", { opacity: 1, y: 0 });
          }

          if (PREFERS_REDUCED) {
            finalizeStatic();
            if (rafId) {
              cancelAnimationFrame(rafId);
              rafId = 0;
            }
          } else {
            gsap.ticker.lagSmoothing(0);
            const tl = gsap.timeline({
              defaults: { ease: "none" },
              scrollTrigger: {
                id: "heroST",
                trigger: heroEl,
                start: "top top",
                end: "+=180%",
                scrub: 1.0,
                pin: true,
                anticipatePin: 1,
                invalidateOnRefresh: true,

                onUpdate: (self) => {
                  // NEW — ramp up pre-spin from 97%→100% while still pinned
                  if (self.direction > 0) {
                    finalBlend = gsap.utils.clamp(
                      0,
                      1,
                      (self.progress - 0.97) / 0.03
                    );
                  } else {
                    finalBlend = 0; // kill pre-spin on upward scrub so rollback feels clean
                  }

                  if (!isFinalized && self.progress >= 0.999) {
                    masterSurface.userData.finalRotation = {
                      x: masterSurface.rotation.x,
                      y: masterSurface.rotation.y,
                      z: masterSurface.rotation.z,
                    };
                    atoms.forEach((a) => (a.userData.baseScale = a.scale.x));
                    center.userData.baseScale = center.scale.x;

                    isScrollComplete = true;
                    isFinalized = true;
                  }
                  // enable full free motion only once unpinned
                  enableFinalMotion = isFinalized && !self.isActive;
                },

                onEnter: () => {
                  if (!rafId) rafId = requestAnimationFrame(render);
                  finalBlend = 0; // reset pre-spin when re-entering
                  enableFinalMotion = false;
                },
                onEnterBack: () => {
                  if (!rafId) rafId = requestAnimationFrame(render);
                  finalBlend = 0;
                  enableFinalMotion = false;
                },
                onLeave: () => {
                  if (!isFinalized) {
                    if (rafId) {
                      cancelAnimationFrame(rafId);
                      rafId = 0;
                    }
                  } else {
                    // immediately switch from pre-spin to full free motion after release
                    enableFinalMotion = true;
                    finalBlend = 0;
                  }
                },
                onLeaveBack: () => {
                  if (!isFinalized && rafId) {
                    cancelAnimationFrame(rafId);
                    rafId = 0;
                  }
                  enableFinalMotion = false;
                  finalBlend = 0;
                },
              },
            });

            tl.set("#copy1", { opacity: 0, y: 12 });
            tl.set("#copy2", { opacity: 0, y: 12 });

            tl.to(
              "#copy1",
              { opacity: 1, y: 0, duration: 0.12, ease: "power2.out" },
              0.22
            );
            tl.to(
              "#copy1",
              { opacity: 0, y: -10, duration: 0.12, ease: "power1.out" },
              0.78
            );
            tl.to(
              "#copy2",
              { opacity: 1, y: 0, duration: 0.18, ease: "power2.out" },
              0.82
            );

            const yawTurn = Math.PI * 2;
            tl.to(
              masterSurface.rotation,
              { y: "+=" + yawTurn, duration: 1 },
              0
            );
            tl.to(
              masterSurface.rotation,
              { x: "+=0.28", z: "-=0.22", duration: 0.5, ease: "sine.inOut" },
              0
            );
            tl.to(
              masterSurface.rotation,
              { x: "-=0.28", z: "+=0.22", duration: 0.5, ease: "sine.inOut" },
              0.5
            );

            const beat = 1 / 5;
            const moveDur = beat * 0.98;

            // Movement animations
            for (let i = 0; i < 5; i++) {
              moveAlongSmoothQuadratic(
                i,
                startPositions[i],
                vias[i],
                targets[i],
                tl,
                moveDur,
                i * beat
              );
            }

            // Bond growth animations
            bonds.forEach((bond, i) => {
              tl.to(
                bond,
                {
                  growth: 1,
                  duration: beat * 0.9,
                  ease: "power2.out",
                  onStart: () => {
                    bond.b.visible = true;
                    bond.a.visible = false;
                  },
                  onComplete: () => {
                    // Enable continuous motion when the last bond completes
                    if (i === bonds.length - 1) {
                      // Store final rotation state
                      masterSurface.userData.finalRotation = {
                        x: masterSurface.rotation.x,
                        y: masterSurface.rotation.y,
                        z: masterSurface.rotation.z,
                      };

                      // Store base scales for breathing animation
                      atoms.forEach((atom) => {
                        atom.userData.baseScale = atom.scale.x;
                      });
                      center.userData.baseScale = center.scale.x;

                      // Enable continuous motion
                      isScrollComplete = true;
                    }
                  },
                },
                i * beat + beat * 0.7
              );
            });
          }
        }

        // Hide poster and update status
        setTimeout(() => posterEl && posterEl.classList.add("hidden"), 150);
        statusEl.textContent = "Bonds visible + section pinned";
        setTimeout(() => statusEl.remove(), 700);
      } catch (err) {
        console.error("WebGL init failed:", err);
        statusEl.textContent = "WebGL not supported. Showing poster.";
        if (rafId) cancelAnimationFrame(rafId);
      }
    </script>
  </body>
</html>
