<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <meta name="color-scheme" content="light dark" />
    <title>Chematek Hero – Bonds + Pin</title>
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin />
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
        margin: 0;
      }
      body {
        background: #0a2746;
        color: #e8eef6;
        font-family: system-ui, Arial, sans-serif;
      }
      :root {
        --vh: 1vh;
      }
      #hero {
        position: relative;
        width: 100%;
        height: 100dvh;
        height: calc(var(--vh) * 100);
        overflow: hidden;
        overscroll-behavior: contain;
        background: radial-gradient(
          120% 120% at 30% 20%,
          #0161ae 0%,
          #06223d 60%,
          #002c50 100%
        );
      }
      #hero canvas {
        display: block;
        width: 100%;
        height: 100%;
      }
      .poster {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        filter: saturate(0.9) brightness(1.05);
      }
      .poster.hidden {
        display: none;
      }
      .status {
        position: absolute;
        inset: auto 0 1rem 0;
        text-align: center;
        font-size: 0.9rem;
        opacity: 0.7;
        pointer-events: none;
      }
      /* Copy overlays (left headline, right paragraph) */
      .copy {
        position: absolute;
        max-width: 44ch;
        line-height: 1.1;
        letter-spacing: 0.02em;
        text-wrap: balance;
      }
      #copy1 {
        left: 4vw;
        top: 22vh;
        font-family: Archimoto V01;
        font-weight: 800;
        font-size: clamp(26px, 5vw, 52px);
        color: #e9eef6;
      }
      #copy2 {
        right: 5vw;
        top: 28vh;
        font-family: Space Grotesk;
        font-weight: 500;
        font-size: clamp(14px, 1.6vw, 18px);
        color: #d9e3ef;
        opacity: 0;
        pointer-events: none;
      }

      /* After section ensures we can test scroll + pin behavior */
      #after {
        min-height: 200vh;
        display: grid;
        place-items: center;
        background: linear-gradient(180deg, #051c33 0%, #0b0a46 100%);
      }

      .copy {
        position: absolute;
        max-width: 44ch;
        line-height: 1.1;
        letter-spacing: 0.02em;
        text-wrap: balance;
      }
      #copy1 {
        left: 4vw;
        top: 22vh;
        font-weight: 800;
        font-size: clamp(30px, 5vw, 60px);
        color: #e9eef6;
      }
      #copy2 {
        right: 5vw;
        top: 80vh;
        font-weight: 500;
        font-size: clamp(18px, 1.6vw, 24px);
        color: #d9e3ef;
        opacity: 0;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <section id="hero" aria-label="Hero 3D stage">
      <img
        class="poster"
        alt="Molecule hero poster"
        src="data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1200' height='800'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop stop-color='%230e3969'/%3E%3Cstop offset='1' stop-color='%23051c33'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect fill='url(%23g)' width='1200' height='800'/%3E%3C/svg%3E"
      />
      <div class="status" id="status">Bonds + Pin setup…</div>
      <div id="copy1" class="copy">
        / IN THE<br />PURSUIT OF<br />
        <span style="color: #f89a5f"> PROGRESS</span>
      </div>
      <div id="copy2" class="copy">
        Chematek is an industrial technology company that offers products,
        services, and solutions for chemicals, lubricants and engineering,
        procurement, and construction.
      </div>
    </section>
    <section id="after">
      <div>Scroll past the pinned hero to verify release behavior.</div>
    </section>

    <!-- Libraries (pinned) -->
    <script src="./assets/vendor/gsap.min.js"></script>
    <script src="./assets/vendor/ScrollTrigger.min.js"></script>
    <script type="module">
      import * as THREE from "./assets/vendor/three.module.min.js";

      // --- Mobile viewport stability ---
      (function setVH() {
        const set = () =>
          document.documentElement.style.setProperty(
            "--vh",
            window.innerHeight * 0.01 + "px"
          );
        set();
        addEventListener("resize", set, { passive: true });
        addEventListener("orientationchange", set);
      })();

      const heroEl = document.getElementById("hero");
      const statusEl = document.getElementById("status");
      const posterEl = document.querySelector(".poster");

      // Cap gating & seating
      const CAP_VIS_EPS = 0.03; // hide caps/halves when growth <= 3%
      const CAP_SHRINK_IN = 0.08; // cap starts shrinking below this
      const CAP_SHRINK_OUT = 0.18; // cap fully grown above this
      const CAP_INSET = 0.02; // push caps slightly into spheres (world units)
      const CAP_SCALE = 1.06; // final cap scale for a soft fillet silhouette

      let renderer, scene, camera, molecule, rafId;

      try {
        // Renderer with DPR cap
        renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: false,
          powerPreference: "high-performance",
        });
        const isCoarse = matchMedia("(pointer: coarse)").matches;
        const dprCap = isCoarse ? 1.75 : 2.0;
        renderer.setPixelRatio(Math.min(devicePixelRatio || 1, dprCap));
        renderer.setSize(heroEl.clientWidth, heroEl.clientHeight, false);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        renderer.physicallyCorrectLights = true;
        renderer.sortObjects = true;
        renderer.outputColorSpace = THREE.SRGBColorSpace; // true sRGB output
        renderer.setClearColor(0x000000, 0);
        heroEl.prepend(renderer.domElement);
        // Keep the molecule comfortably framed across devices (no group scaling)
        function updateCameraForViewport() {
          const w = window.innerWidth;

          // Baseline: desktop wide screens
          let z = 8.0;

          // Tablets / small laptops
          if (w <= 1280) z = 8.4;

          // Large phones / phablets
          if (w <= 900) z = 8.8;

          // Narrow phones
          if (w <= 600) z = 9.2;

          // Very narrow phones (<= 380–420 px)
          if (w <= 420) z = 9.6;

          camera.position.z = z;
          camera.updateProjectionMatrix();
        }

        // Scene & camera
        scene = new THREE.Scene();
        // scene.background = new THREE.Color(0x053b6c);
        camera = new THREE.PerspectiveCamera(
          35,
          heroEl.clientWidth / heroEl.clientHeight,
          0.1,
          100
        );
        camera.position.set(0, 0, 8);

        // Fixed lighting (never animate)
        const key = new THREE.DirectionalLight(0xffffff, 1.05);
        key.position.set(2.2, 3.0, 4.0);
        const rim = new THREE.DirectionalLight(0xaecbff, 0.38);
        rim.position.set(-3.0, 1.2, -2.2);
        const amb = new THREE.AmbientLight(0xffffff, 0.18);
        scene.add(key, rim, amb);
        // --- Lightweight PMREM environment for glass (no external HDR needed) ---
        const pmrem = new THREE.PMREMGenerator(renderer);
        pmrem.compileEquirectangularShader();

        // Build a tiny LDR "studio": a dark room box + a few bright panels
        const envScene = new THREE.Scene();
        const room = new THREE.Mesh(
          new THREE.BoxGeometry(10, 10, 10),
          new THREE.MeshBasicMaterial({ color: 0x0a2746, side: THREE.BackSide })
        );
        envScene.add(room);

        // helper to add a bright panel
        function panel(x, y, z, rx, ry, w, h, luminance) {
          const m = new THREE.Mesh(
            new THREE.PlaneGeometry(w, h),
            new THREE.MeshBasicMaterial({ color: 0xffffff })
          );
          m.position.set(x, y, z);
          m.rotation.set(rx, ry, 0);
          m.material.color.setScalar(luminance);
          envScene.add(m);
        }
        // a few asymmetric panels for nice glints/reflections
        panel(-2.2, 2.1, -3.0, 0.0, 0.0, 3.0, 2.0, 3.0);
        panel(3.0, -1.0, 2.2, 0.0, Math.PI / 2, 2.0, 1.5, 2.4);
        panel(-3.2, -2.0, 1.0, 0.0, -Math.PI / 2, 1.4, 2.4, 2.1);

        // Bake environment for IBL/transmission
        const envRT = pmrem.fromScene(envScene, 0.04);
        scene.environment = envRT.texture;

        // Materials (glass/water tuning; navy tint preserved)
        const baseColor = 0x1c1a70; // 010155

        const atomMat = new THREE.MeshPhysicalMaterial({
          color: baseColor,
          roughness: 0.08, // cleaner highlights
          metalness: 0.0, // glass is dielectric
          clearcoat: 1.0,
          clearcoatRoughness: 0.06,
          transmission: 0.9, // strong transmission
          ior: 1.333, // water-like IOR
          thickness: 0.4, // more body for internal darkening
          attenuationColor: new THREE.Color(baseColor),
          attenuationDistance: 1.6, // shorter distance: richer tint without going murky
          envMapIntensity: 1.25, // brighter reflections/refractions from env
          opacity: 1.0, // fully present (transmission handles “glassiness”)
        });

        const bondMat = atomMat.clone();
        // Slightly less transmissive rods keep joints readable
        bondMat.transmission = 0.82;
        bondMat.thickness = 0.34;
        bondMat.envMapIntensity = 1.15;

        atomMat.transparent = true;
        bondMat.transparent = true;
        // Keep depthWrite ON for now to avoid ordering mess; renderOrder already enforces a stable stack.
        // If you later want true see-through overlaps, we’ll flip these to false and harden ordering:
        // atomMat.depthWrite = false;
        // bondMat.depthWrite = false;

        // Deterministic random so the initial scatter is stable per reload
        function seeded(i) {
          return Math.sin(i * 16807.123) % 1;
        }
        function rand(i, min, max) {
          const r = Math.abs(seeded(i));
          return min + r * (max - min);
        }

        const baseRadius = 0.5;

        // Root for everything in the molecule hero
        molecule = new THREE.Group();
        scene.add(molecule);

        const masterSurface = new THREE.Group(); // local Y ⟂ MASTERSURFACE
        molecule.add(masterSurface);

        const centerGroup = new THREE.Group();
        const ringGroup = new THREE.Group();
        masterSurface.add(centerGroup, ringGroup);
        masterSurface.rotation.set(Math.PI / 1.5, -0.2, 0.0);

        // Geometry radius must match baseRadius so bond halves start at the true surface
        const atomGeo = new THREE.SphereGeometry(baseRadius, 48, 48);

        // Central atom: fixed position & constant scale (storyboard panel 1)
        const center = new THREE.Mesh(atomGeo, atomMat);
        center.position.set(0, 0, 0);
        center.scale.setScalar(1); // constant; no growth/tween
        centerGroup.add(center);
        center.renderOrder = 0;

        // Outer atoms (A..E) placed ON the MASTERSURFACE plane (z=0 in its local space).
        // Depth differences now come from the plane tilt (PATCH A), not per-atom Z.
        const Rplane = 2.2; // ring radius in the MASTERSURFACE plane
        const baseAngle = Math.PI / 2; // A at top
        const step = (2 * Math.PI) / 5;

        const startRing = Array.from({ length: 5 }, (_, i) => {
          const ang = baseAngle - i * step; // A,B,C,D,E around the circle
          return new THREE.Vector3(
            Math.cos(ang) * Rplane,
            Math.sin(ang) * Rplane,
            0
          );
        });

        const atoms = [
          { id: "A" },
          { id: "B" },
          { id: "C" },
          { id: "D" },
          { id: "E" },
        ].map((d, i) => {
          const m = new THREE.Mesh(atomGeo, atomMat);
          m.position.copy(startRing[i]); // A..E with planned depths
          m.scale.setScalar(1 + Math.random() * 0.35); // no growth now (you disabled growth phase)
          ringGroup.add(m);
          m.renderOrder = 2;
          return m;
        });

        // --- Targets & via control points (for assembly) ---
        // Snapshot *after* random spawn so we can tween from these
        const startPositions = atoms.map((m) => m.position.clone());

        // Non-coplanar hub-and-spokes (1 center + 5 outers):
        // Use two **axial** positions (±Z) and three **equatorial** on XY.
        // Keeps all center↔outer distances == R.
        const R = 1.8;
        const targets = [
          new THREE.Vector3(0.0, 0.0, R), // 0 axial +Z
          new THREE.Vector3(0.0, 0.0, -R), // 1 axial −Z
          new THREE.Vector3(0.0, R, 0.0), // 2 equatorial
          new THREE.Vector3(
            R * Math.cos(-Math.PI / 6), // 3 equatorial
            R * Math.sin(-Math.PI / 6),
            0.0
          ),
          new THREE.Vector3(
            R * Math.cos((7 * Math.PI) / 6), // 4 equatorial
            R * Math.sin((7 * Math.PI) / 6),
            0.0
          ),
        ];

        // Gentle 3D approach arcs (keep Z modest; axial paths bow toward ±Z)
        const vias = {
          0: new THREE.Vector3(
            startPositions[0].x * 0.6,
            startPositions[0].y * 0.6,
            R * 0.4
          ),
          1: new THREE.Vector3(
            startPositions[1].x * 0.6,
            startPositions[1].y * 0.6,
            -R * 0.4
          ),
          2: new THREE.Vector3(targets[2].x * 0.6, targets[2].y * 0.6, -0.22),
          3: new THREE.Vector3(targets[3].x * 0.6, targets[3].y * 0.6, 0.22),
          4: new THREE.Vector3(targets[4].x * 0.6, targets[4].y * 0.6, -0.18),
        };

        // Bond / cap dimensions (keep caps slightly fuller than the rod for a meniscus look)
        const bondRadius = 0.12;
        const halfGeo = new THREE.CylinderGeometry(
          bondRadius,
          bondRadius,
          1,
          24
        );
        halfGeo.translate(0, 0.5, 0);

        // Meniscus/fillet: a small sphere used as a cap at each sphere↔rod interface
        const capGeo = new THREE.SphereGeometry(bondRadius * 1.15, 24, 18);

        const bonds = []; // { a, b, capA, capB, growth, outerIdx }

        function createCenterBond(outerIdx) {
          const aHalf = new THREE.Mesh(halfGeo, bondMat); // center-side half
          const bHalf = new THREE.Mesh(halfGeo, bondMat); // outer-side half
          aHalf.visible = bHalf.visible = false;
          // Parent halves to molecule root so they aren’t double-transformed
          molecule.add(aHalf, bHalf);
          aHalf.renderOrder = 1;
          bHalf.renderOrder = 1;

          const capA = new THREE.Mesh(capGeo, bondMat);
          const capB = new THREE.Mesh(capGeo, bondMat);
          capA.visible = capB.visible = false;
          molecule.add(capA, capB);
          capA.renderOrder = 1;
          capB.renderOrder = 1;

          // Meniscus caps (center-side & outer-side)
          const capC = new THREE.Mesh(capGeo, bondMat);
          const capO = new THREE.Mesh(capGeo, bondMat);
          capC.visible = capO.visible = false;
          molecule.add(capC, capO);
          capC.renderOrder = 1;
          capO.renderOrder = 1;

          // Keep glass draw order stable: center → bonds/caps → outers
          aHalf.renderOrder = bHalf.renderOrder = 1;
          capC.renderOrder = capO.renderOrder = 1;

          const pair = {
            a: aHalf,
            b: bHalf,
            capA: capC,
            capB: capO,
            growth: 0,
            outerIdx,
          };
          bonds.push(pair);
          return pair;
        }

        // Create five center↔outer bonds (order will be handled by the timeline)
        createCenterBond(0);
        createCenterBond(1);
        createCenterBond(2);
        createCenterBond(3);
        createCenterBond(4);
        for (const b of bonds) {
          b.growth = 0;
          b.a.visible = b.b.visible = false;
        }

        const UP = new THREE.Vector3(0, 1, 0);
        const tmpDir = new THREE.Vector3();
        const tmpDirN = new THREE.Vector3(); // normalized direction
        const tmpV1 = new THREE.Vector3(); // scratch mul/add
        const tmpV2 = new THREE.Vector3(); // scratch mul/add
        const tmpNeg = new THREE.Vector3();

        // Bonds should be present the whole time for this storyboard phase

        // temp vectors reused each call
        const tmpCw = new THREE.Vector3(); // center world
        const tmpOw = new THREE.Vector3(); // outer world
        const tmpCl = new THREE.Vector3(); // center in molecule space
        const tmpOl = new THREE.Vector3(); // outer in molecule space

        function positionCenterBond(pair) {
          // 1) sample **world** positions
          center.getWorldPosition(tmpCw);
          atoms[pair.outerIdx].getWorldPosition(tmpOw);

          // 2) convert to the bond's parent space (molecule)
          tmpCl.copy(tmpCw);
          molecule.worldToLocal(tmpCl);
          tmpOl.copy(tmpOw);
          molecule.worldToLocal(tmpOl);

          // 3) direction & distances in **molecule space**
          tmpDir.subVectors(tmpOl, tmpCl);
          const centerDist = tmpDir.length();
          const g = pair.growth;
          const show = g > CAP_VIS_EPS;

          pair.a.visible = show;
          pair.b.visible = show;
          pair.capA.visible = show;
          pair.capB.visible = show;

          // Smooth shrink/grow of caps so they never linger as dots
          const t = Math.min(
            Math.max((g - CAP_SHRINK_IN) / (CAP_SHRINK_OUT - CAP_SHRINK_IN), 0),
            1
          );
          const s = CAP_SCALE * t;
          pair.capA.scale.setScalar(s);
          pair.capB.scale.setScalar(s);

          const rC = baseRadius * center.scale.x;
          const rO = baseRadius * atoms[pair.outerIdx].scale.x;

          const coreLen = Math.max(0, centerDist - (rC + rO));
          const halfLen = coreLen * 0.5;

          if (halfLen <= 1e-6 || g <= 0) {
            pair.a.visible = pair.b.visible = false;
            return;
          }

          const dir = tmpDirN.copy(tmpDir).normalize();

          // Center-side half (aiming outward from **tmpCl**)
          pair.a.visible = true;
          pair.a.position.copy(tmpCl).add(dir.clone().multiplyScalar(rC));
          pair.a.quaternion.setFromUnitVectors(UP, dir);
          pair.a.scale.set(1, halfLen * g, 1);

          // Outer-side half (aiming inward from **tmpOl**)
          pair.b.visible = true;
          pair.b.position.copy(tmpOl).add(tmpV2.copy(dir).multiplyScalar(-rO));
          tmpNeg.copy(dir).multiplyScalar(-1);
          pair.b.quaternion.setFromUnitVectors(UP, tmpNeg);
          pair.b.scale.set(1, halfLen * g, 1);

          // Meniscus caps at each interface (visible once growth begins)
          const showCap = g > 0.001;

          // Place caps right where the rod meets each sphere surface
          pair.capA.position
            .copy(tmpCl)
            .add(tmpV1.copy(dir).multiplyScalar(rC));
          pair.capB.position
            .copy(tmpOl)
            .add(tmpV2.copy(dir).multiplyScalar(-rO));
        }

        // Build a small LUT for arc-length → parameter mapping
        function buildBezierLUT(p0, p1, p2, samples = 80) {
          const pts = new Array(samples + 1);
          const len = new Float32Array(samples + 1);
          let acc = 0;
          for (let i = 0; i <= samples; i++) {
            const t = i / samples,
              it = 1 - t;
            const x = it * it * p0.x + 2 * it * t * p1.x + t * t * p2.x;
            const y = it * it * p0.y + 2 * it * t * p1.y + t * t * p2.y;
            const z = it * it * p0.z + 2 * it * t * p1.z + t * t * p2.z;
            pts[i] = new THREE.Vector3(x, y, z);
            if (i) acc += pts[i].distanceTo(pts[i - 1]);
            len[i] = acc;
          }
          return { pts, len, total: acc };
        }
        function tFromS(lut, s) {
          const target = s * lut.total;
          // binary search
          let lo = 0,
            hi = lut.len.length - 1;
          while (lo < hi) {
            const mid = (lo + hi) >> 1;
            lut.len[mid] < target ? (lo = mid + 1) : (hi = mid);
          }
          const i = Math.max(1, lo);
          const l0 = lut.len[i - 1],
            l1 = lut.len[i];
          const f = (target - l0) / Math.max(1e-6, l1 - l0);
          return (i - 1 + f) / (lut.len.length - 1);
        }
        function moveAlongQuadraticCS(atomIdx, p0, p1, p2, tl, dur, at) {
          const lut = buildBezierLUT(p0, p1, p2, 80);
          const proxy = { s: 0 }; // normalized distance
          tl.to(
            proxy,
            {
              s: 1,
              duration: dur,
              ease: "none", // constant-speed in arc length
              onUpdate: () => {
                const t = tFromS(lut, proxy.s),
                  it = 1 - t;
                const x = it * it * p0.x + 2 * it * t * p1.x + t * t * p2.x;
                const y = it * it * p0.y + 2 * it * t * p1.y + t * t * p2.y;
                const z = it * it * p0.z + 2 * it * t * p1.z + t * t * p2.z;
                atoms[atomIdx].position.set(x, y, z);
              },
            },
            at
          );
        }

        // Micro-drift (very subtle, no Z)
        let t = 0;
        function render() {
          t += 0.01;

          // No drift (per spec) — atoms stay fixed unless GSAP rotates the ring
          // Ensure transforms from GSAP are applied before we read positions
          scene.updateMatrixWorld(true);

          // Keep bonds glued to both ends every frame
          for (let i = 0; i < bonds.length; i++) positionCenterBond(bonds[i]);

          // Draw and schedule next frame
          renderer.render(scene, camera);
          rafId = requestAnimationFrame(render);
        }
        rafId = requestAnimationFrame(render);

        // Resize/orientation
        let resizeRAF;
        const onResize = () => {
          // Use rect to avoid stale clientWidth during pin/unpin
          const rect = heroEl.getBoundingClientRect();
          const w = Math.max(1, Math.floor(rect.width));
          const h = Math.max(1, Math.floor(rect.height));

          // DPR can change with zoom/orientation; recalc and cap
          const isCoarse = matchMedia("(pointer: coarse)").matches;
          const dprCap = isCoarse ? 1.75 : 2.0;
          const nextDpr = Math.min(window.devicePixelRatio || 1, dprCap);
          if (renderer.getPixelRatio() !== nextDpr)
            renderer.setPixelRatio(nextDpr);

          // Camera + renderer viewport
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
          renderer.setSize(w, h, false);
          updateCameraForViewport();

          // Recompute ScrollTrigger measurements after layout settles
          if (window.ScrollTrigger) {
            cancelAnimationFrame(resizeRAF);
            resizeRAF = requestAnimationFrame(() => ScrollTrigger.refresh());
          }
        };
        addEventListener("resize", onResize, { passive: true });
        addEventListener("orientationchange", onResize);
        // Safari bfcache + mobile re-activation can yield stale sizes
        addEventListener(
          "pageshow",
          (e) => {
            if (e.persisted) onResize();
          },
          { passive: true }
        );
        onResize();

        // Master GSAP timeline: pin + scrub + assembly + orbit
        if (window.gsap && window.ScrollTrigger) {
          const PREFERS_REDUCED = window.matchMedia(
            "(prefers-reduced-motion: reduce)"
          ).matches;

          updateCameraForViewport();

          // Final static state (no scroll-scrub, no rotation)
          function finalizeStatic() {
            atoms.forEach((m, i) => m.position.copy(targets[i]));

            // Fully grow all bonds and show caps
            bonds.forEach((pair) => {
              pair.growth = 1;
              if (pair.a) pair.a.visible = true;
              if (pair.b) pair.b.visible = true;
              if (pair.capA) pair.capA.visible = true;
              if (pair.capB) pair.capB.visible = true;
            });

            // No rotation in reduced-motion
            masterSurface.rotation.set(0, 0, 0);

            // Copy: show final message only
            gsap.set("#copy1", { opacity: 0, y: -10 });
            gsap.set("#copy2", { opacity: 1, y: 0 });
          }
          // Master GSAP timeline: full 3D rotation + sequential bond joins
          if (PREFERS_REDUCED) {
            // Accessibility: present final composition as a static hero
            finalizeStatic();
            if (rafId) {
              cancelAnimationFrame(rafId);
              rafId = 0;
            } // stop rendering
          } else {
            gsap.ticker.lagSmoothing(0); // avoid "catch-up" jumps after stalls
            const tl = gsap.timeline({
              defaults: { ease: "none" },
              scrollTrigger: {
                trigger: heroEl,
                start: "top top",
                end: "+=180%",
                scrub: true,
                pin: true,
                anticipatePin: 1, // smoother pin handoff
                invalidateOnRefresh: true, // recalc on resize/orientation
                onEnter: () => {
                  if (!rafId) rafId = requestAnimationFrame(render);
                },
                onEnterBack: () => {
                  if (!rafId) rafId = requestAnimationFrame(render);
                },
                onLeave: () => {
                  if (rafId) {
                    cancelAnimationFrame(rafId);
                    rafId = 0;
                  }
                },
                onLeaveBack: () => {
                  if (rafId) {
                    cancelAnimationFrame(rafId);
                    rafId = 0;
                  }
                },
              },
            });
            tl.set("#copy1", { opacity: 0, y: 12 });
            tl.set("#copy2", { opacity: 0, y: 12 });

            tl.to(
              "#copy1",
              { opacity: 1, y: 0, duration: 0.12, ease: "power2.out" },
              0.22
            );

            // Headline out (78%) before paragraph enters
            tl.to(
              "#copy1",
              { opacity: 0, y: -10, duration: 0.12, ease: "power1.out" },
              0.78
            );

            // Paragraph in (82%) for the composed state
            tl.to(
              "#copy2",
              { opacity: 1, y: 0, duration: 0.18, ease: "power2.out" },
              0.82
            );

            // 3D spin over the whole scroll: yaw 360°, gentle pitch/roll that return to start
            const yawTurn = Math.PI * 2;
            tl.to(
              masterSurface.rotation,
              { y: "+=" + yawTurn, duration: 1 },
              0
            );
            tl.to(
              masterSurface.rotation,
              { x: "+=0.28", z: "-=0.22", duration: 0.5, ease: "sine.inOut" },
              0
            );
            tl.to(
              masterSurface.rotation,
              { x: "-=0.28", z: "+=0.22", duration: 0.5, ease: "sine.inOut" },
              0.5
            );

            tl.to(
              "#copy1",
              { opacity: 1, y: 0, duration: 0.12, ease: "power2.out" },
              0.22
            );
            tl.to(
              "#copy1",
              { opacity: 0, y: -10, duration: 0.12, ease: "power1.out" },
              0.78
            );
            tl.to(
              "#copy2",
              { opacity: 1, y: 0, duration: 0.18, ease: "power2.out" },
              0.82
            );

            // Sequential joins: five equal beats across the scroll
            const beat = 1 / 5;
            const moveDur = beat * 0.95;
            moveAlongQuadraticCS(
              0,
              startPositions[0],
              vias[0],
              targets[0],
              tl,
              moveDur,
              0 * beat
            );
            moveAlongQuadraticCS(
              1,
              startPositions[1],
              vias[1],
              targets[1],
              tl,
              moveDur,
              1 * beat
            );
            moveAlongQuadraticCS(
              2,
              startPositions[2],
              vias[2],
              targets[2],
              tl,
              moveDur,
              2 * beat
            );
            moveAlongQuadraticCS(
              3,
              startPositions[3],
              vias[3],
              targets[3],
              tl,
              moveDur,
              3 * beat
            );
            moveAlongQuadraticCS(
              4,
              startPositions[4],
              vias[4],
              targets[4],
              tl,
              moveDur,
              4 * beat
            );
            tl.to(
              bonds[0],
              {
                growth: 1,
                duration: beat * 0.9,
                ease: "power2.out",
                onStart: () => {
                  bonds[0].a.visible = bonds[0].b.visible = true;
                },
              },
              0 * beat + beat * 0.7
            );
            tl.to(
              bonds[1],
              {
                growth: 1,
                duration: beat * 0.9,
                ease: "power2.out",
                onStart: () => {
                  bonds[1].a.visible = bonds[1].b.visible = true;
                },
              },
              1 * beat + beat * 0.7
            );
            tl.to(
              bonds[2],
              {
                growth: 1,
                duration: beat * 0.9,
                ease: "power2.out",
                onStart: () => {
                  bonds[2].a.visible = bonds[2].b.visible = true;
                },
              },
              2 * beat + beat * 0.7
            );
            tl.to(
              bonds[3],
              {
                growth: 1,
                duration: beat * 0.9,
                ease: "power2.out",
                onStart: () => {
                  bonds[3].a.visible = bonds[3].b.visible = true;
                },
              },
              3 * beat + beat * 0.7
            );
            tl.to(
              bonds[4],
              {
                growth: 1,
                duration: beat * 0.9,
                ease: "power2.out",
                onStart: () => {
                  bonds[4].a.visible = bonds[4].b.visible = true;
                },
              },
              4 * beat + beat * 0.7
            );
          }
        }
        // Hide poster once rendering is alive
        setTimeout(() => posterEl && posterEl.classList.add("hidden"), 150);
        statusEl.textContent = "Bonds visible + section pinned";
        setTimeout(() => statusEl.remove(), 700);
      } catch (err) {
        console.error("WebGL init failed:", err);
        statusEl.textContent = "WebGL not supported. Showing poster.";
        if (rafId) cancelAnimationFrame(rafId);
      }
    </script>
  </body>
</html>
