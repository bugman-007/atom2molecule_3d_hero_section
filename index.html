<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <meta name="color-scheme" content="light dark" />
    <title>Chematek Hero — Spin-Only (Client Baseline)</title>
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin />
    <style>
      *,*::before,*::after{box-sizing:border-box}
      html,body{height:100%;margin:0}
      body{background:#0a2746;color:#e8eef6;font-family:system-ui,Arial,sans-serif}
      :root{--vh:1vh}
      #hero{
        position:relative;width:100%;
        height:100dvh;height:calc(var(--vh)*100);
        overflow:hidden;overscroll-behavior:contain;
        background:radial-gradient(120% 120% at 30% 20%,#0161ae 0%,#06223d 60%,#002c50 100%);
      }
      #hero canvas{display:block;width:100%;height:100%}
      .poster{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;filter:saturate(.9) brightness(1.05)}
      .poster.hidden{display:none}
      .status{position:absolute;inset:auto 0 1rem 0;text-align:center;font-size:.9rem;opacity:.7;pointer-events:none}
      .copy{position:absolute;max-width:44ch;line-height:1.1;letter-spacing:.02em;text-wrap:balance}
      #copy1,#copy2{opacity:0;pointer-events:none}
      #after{min-height:200vh;display:grid;place-items:center;background:linear-gradient(180deg,#051c33 0%,#0b0a46 100%)}
    </style>
  </head>
  <body>
    <section id="hero" aria-label="Hero 3D stage">
      <img class="poster" alt="Molecule hero poster"
        src="data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1200' height='800'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop stop-color='%230e3969'/%3E%3Cstop offset='1' stop-color='%23051c33'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect fill='url(%23g)' width='1200' height='800'/%3E%3C/svg%3E" />
      <div class="status" id="status">Spin-only baseline…</div>
      <div id="copy1" class="copy"></div>
      <div id="copy2" class="copy"></div>
    </section>
    <section id="after"><div>Scroll past the pinned hero to verify release behavior.</div></section>

    <script src="./assets/vendor/gsap.min.js"></script>
    <script src="./assets/vendor/ScrollTrigger.min.js"></script>
    <script>if (window.gsap && window.ScrollTrigger){gsap.registerPlugin(ScrollTrigger);}</script>

    <script type="module">
      import * as THREE from "./assets/vendor/three.module.min.js";

      // --- Viewport unit stability for mobile
      (function setVH(){
        const set=()=>document.documentElement.style.setProperty("--vh", window.innerHeight*0.01 + "px");
        set(); addEventListener("resize", set, {passive:true}); addEventListener("orientationchange", set);
      })();

      const heroEl = document.getElementById("hero");
      const statusEl = document.getElementById("status");
      const posterEl = document.querySelector(".poster");

      // === Bokeh BG (under everything; keep CSS fallback until first paint)
      (function(){
        const host = heroEl;
        const bg = document.createElement("canvas");
        const g = bg.getContext("2d", {alpha:false});
        bg.style.position="absolute"; bg.style.inset="0"; bg.style.pointerEvents="none";
        bg.style.zIndex="-2"; // sits under gradient canvas
        host.prepend(bg);

        const GOLD="#ffcf86", GOLD_2="#ffc261", BASE="#050505";
        let W=0,H=0,DPR=1,running=true, firstPaint=false;
        const M=26, discs=[];

        function resize(){
          DPR = Math.min(window.devicePixelRatio||1, 1.75);
          W = Math.max(1, host.clientWidth); H = Math.max(1, host.clientHeight);
          bg.width = Math.floor(W*DPR); bg.height = Math.floor(H*DPR);
          bg.style.width=W+"px"; bg.style.height=H+"px";
          g.setTransform(DPR,0,0,DPR,0,0);
        }
        function spawn(){
          discs.length=0;
          for(let i=0;i<M;i++){
            const r=(Math.random()*80+50)*(H/800), x=Math.random()*W, y=Math.random()*H;
            const s=(0.15+Math.random()*0.35)*0.12, a=Math.random()*Math.PI*2;
            discs.push({x,y,r,s,a,phi:Math.random()*6.28});
          }
        }
        function grad(x,y,r){const t=g.createRadialGradient(x,y,r*0.05,x,y,r);t.addColorStop(0,"rgba(255,230,180,0.85)");t.addColorStop(0.45,GOLD);t.addColorStop(1,"rgba(0,0,0,0)");return t;}
        function frame(t){
          if(!running) return;
          g.fillStyle=BASE; g.fillRect(0,0,W,H);
          for(const d of discs){
            d.a += d.s*0.5; d.phi += 0.002;
            d.x += Math.cos(d.a)*d.s*30.0; d.y += Math.sin(d.a)*d.s*18.0;
            if(d.x<-d.r) d.x=W+d.r; if(d.x>W+d.r) d.x=-d.r;
            if(d.y<-d.r) d.y=H+d.r; if(d.y>H+d.r) d.y=-d.r;

            g.globalCompositeOperation="lighter"; g.fillStyle=grad(d.x,d.y,d.r);
            g.beginPath(); g.arc(d.x,d.y,d.r,0,Math.PI*2); g.fill();

            g.globalCompositeOperation="screen"; g.fillStyle=GOLD_2; g.globalAlpha=0.06;
            g.beginPath(); g.arc(d.x,d.y,d.r*0.35*(1+0.2*Math.sin(d.phi)),0,Math.PI*2); g.fill();
            g.globalAlpha=1;
          }
          g.globalCompositeOperation="source-over";
          if(!firstPaint){ heroEl.style.background="transparent"; firstPaint=true; }
          requestAnimationFrame(frame);
        }
        resize(); spawn(); requestAnimationFrame(frame);
        addEventListener("resize", ()=>{resize(); spawn();});
        document.addEventListener("visibilitychange", ()=>{running=!document.hidden; if(running) requestAnimationFrame(frame);});
      })();

      // === Three.js scene
      let renderer, scene, camera, molecule, rafId;
      let spinRig; // new parent for stable spin axis
      let bonds = [], atoms = [], center;

      // Materials/geometry
      const CONFIG = {
        BASE_RADIUS: 0.25,
        BOND_RADIUS: 0.07,
        TARGET_RADIUS: 0.9,
        BASE_COLOR: 0x1a509b,
      };

      try{
        renderer = new THREE.WebGLRenderer({antialias:true, alpha:false, powerPreference:"high-performance"});
        const isCoarse = matchMedia("(pointer: coarse)").matches;
        const dprCap = isCoarse ? 1.75 : 2.0;
        renderer.setPixelRatio(Math.min(devicePixelRatio||1, dprCap));
        renderer.setSize(heroEl.clientWidth, heroEl.clientHeight, false);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.setClearColor(0x000000, 0);
        heroEl.prepend(renderer.domElement);

        function updateCameraForViewport(){
          const w = heroEl.clientWidth; // container-based for consistency
          let z = 5.0; if (w<=1280) z=5.4; if (w<=900) z=5.8; if (w<=600) z=6.2; if (w<=420) z=6.6;
          camera.position.z = z; camera.updateProjectionMatrix();
        }

        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(35, heroEl.clientWidth/heroEl.clientHeight, 0.1, 100);
        camera.position.set(0,0,5);

        // Lights
        const key = new THREE.DirectionalLight(0xfff4e6, 2.75); key.position.set(20.2,30.0,40.0);
        const rim = new THREE.DirectionalLight(0xf49a59, 3.38); rim.position.set(-3.0,1.2,-2.2);
        const amb = new THREE.AmbientLight(0xfff4e6, 0.12);
        scene.add(key,rim,amb);

        // Simple env via PMREM from colored planes
        const pmrem = new THREE.PMREMGenerator(renderer); pmrem.compileEquirectangularShader();
        const envScene = new THREE.Scene();
        envScene.add(new THREE.Mesh(new THREE.BoxGeometry(10,10,10), new THREE.MeshBasicMaterial({color:0x0a2746, side:THREE.BackSide})));
        [[-2.2,2.1,-3.0,0,0,3.2,2.2,0xffd6b8,2.9],[3.0,-1.0,2.2,0,Math.PI/2,2.2,1.7,0xfff0e0,2.2],[-3.2,-2.0,1.0,0,-Math.PI/2,1.6,2.3,0xf49a59,1.7]]
          .forEach(([x,y,z,rx,ry,w,h,hex,inten])=>{
            const m=new THREE.Mesh(new THREE.PlaneGeometry(w,h), new THREE.MeshBasicMaterial({color:hex}));
            m.position.set(x,y,z); m.rotation.set(rx,ry,0); m.material.color.multiplyScalar(inten); envScene.add(m);
          });
        const envRT = pmrem.fromScene(envScene, 0.04); scene.environment = envRT.texture;

        // Materials
        const atomMat = new THREE.MeshPhysicalMaterial({
          color: CONFIG.BASE_COLOR, roughness:0.95, metalness:0.3,
          transmission:0.5, ior:3.1, thickness:0.3,
          attenuationColor:new THREE.Color(CONFIG.BASE_COLOR), attenuationDistance:1.6,
          envMapIntensity:1.46, transparent:true
        });
        const bondMat = atomMat.clone(); bondMat.transmission=0.82; bondMat.thickness=0.42; bondMat.envMapIntensity=1.25;

        // Geometries
        const atomGeo = new THREE.SphereGeometry(CONFIG.BASE_RADIUS,48,48);
        const halfGeo = new THREE.CylinderGeometry(CONFIG.BOND_RADIUS, CONFIG.BOND_RADIUS, 1, 24); halfGeo.translate(0,0.5,0);

        // Structure
        // SpinRig -> molecule -> masterSurface
        spinRig = new THREE.Group(); scene.add(spinRig);
        molecule = new THREE.Group(); spinRig.add(molecule);
        const masterSurface = new THREE.Group(); molecule.add(masterSurface);
        const centerGroup = new THREE.Group(); const ringGroup = new THREE.Group();
        masterSurface.add(centerGroup, ringGroup);
        // Aesthetic orientation of the molecule itself (static during the spin pass)
        masterSurface.rotation.set(Math.PI/1.5, -0.2, 0.0);
        masterSurface.userData.rotGoal = {x:masterSurface.rotation.x, y:masterSurface.rotation.y, z:masterSurface.rotation.z};
        // --- Spin axis (NOT local Y). Use a diagonal so it's never colinear with any bond.
        const SPIN_AXIS = new THREE.Vector3(0.61, 0.51, 0.61).normalize();
        // Yaw accumulator for the spin rig; GSAP animates this scalar.
        spinRig.userData.yawGoal = 0;
        const _spinQuatTarget = new THREE.Quaternion();
        const _spinQuatCurrent = new THREE.Quaternion(); // current rig quat snapshot

        // Center atom
        center = new THREE.Mesh(atomGeo, atomMat); center.position.set(0,0,0); center.scale.setScalar(1); center.userData.baseScale=center.scale.x;
        centerGroup.add(center); center.renderOrder=0;

        // Target positions (final bonded layout)
        const R = CONFIG.TARGET_RADIUS;
        const targets = [
          new THREE.Vector3(0,0,R),
          new THREE.Vector3(0,0,-R),
          new THREE.Vector3(0,R,0),
          new THREE.Vector3(R*Math.cos(-Math.PI/6), R*Math.sin(-Math.PI/6), 0),
          new THREE.Vector3(R*Math.cos(7*Math.PI/6), R*Math.sin(7*Math.PI/6), 0),
        ];

        // Outer atoms — place directly at targets (already finished state)
        atoms = Array.from({length:5}, (_,i)=>{
          const m=new THREE.Mesh(atomGeo, atomMat);
          m.position.copy(targets[i]);
          m.scale.setScalar(1.2 + Math.random()*0.45);
          m.userData.baseScale = m.scale.x;
          ringGroup.add(m); m.renderOrder=2; return m;
        });

        // Bonds — fully visible from frame 0 (no growth)
        function createCenterBond(outerIdx){
          const bHalf = new THREE.Mesh(halfGeo, bondMat);
          bHalf.visible = true; molecule.add(bHalf); bHalf.renderOrder=1;
          const pair={a:null,b:bHalf,outerIdx,growth:1,growthGoal:1}; bonds.push(pair); return pair;
        }
        for(let i=0;i<5;i++) createCenterBond(i);

        // Bond positioning (straight, extend into atoms)
        const UP = new THREE.Vector3(0,1,0), tmp = {
          cw:new THREE.Vector3(), ow:new THREE.Vector3(),
          cl:new THREE.Vector3(), ol:new THREE.Vector3(),
          dir:new THREE.Vector3(), dirN:new THREE.Vector3(), neg:new THREE.Vector3()
        };
        const overlap = CONFIG.BASE_RADIUS * 0.6;
        function positionCenterBond(pair){
          center.getWorldPosition(tmp.cw); atoms[pair.outerIdx].getWorldPosition(tmp.ow);
          tmp.cl.copy(tmp.cw); molecule.worldToLocal(tmp.cl);
          tmp.ol.copy(tmp.ow); molecule.worldToLocal(tmp.ol);
          tmp.dir.subVectors(tmp.ol,tmp.cl);
          const centerDist = tmp.dir.length(); if (centerDist <= overlap*2) { pair.b.visible=false; return; }
          const len = Math.max(0, centerDist - overlap*2);
          tmp.dirN.copy(tmp.dir).normalize();
          pair.b.visible=true;
          pair.b.position.copy(tmp.ol).add(tmp.dirN.clone().multiplyScalar(-overlap));
          tmp.neg.copy(tmp.dirN).multiplyScalar(-1);
          pair.b.quaternion.setFromUnitVectors(UP, tmp.neg);
          pair.b.scale.set(1, len, 1);
        }

        // Render loop (no pre-flight; idle breathing after release only)
        let time=0, finalBlend=0, enableFinalMotion=false, isFinalized=false;
        const clock = new THREE.Clock();
        function damp(cur,tgt,dt,lam){const k=1-Math.exp(-lam*dt);return cur+(tgt-cur)*k;}
        function render(){
          const dt=clock.getDelta(); time+=0.008;
          // Viscous group rotation
          const g=masterSurface.userData.rotGoal;
          masterSurface.rotation.x = damp(masterSurface.rotation.x, g.x, dt, 1.8);
          masterSurface.rotation.y = damp(masterSurface.rotation.y, g.y, dt, 1.8);
          masterSurface.rotation.z = damp(masterSurface.rotation.z, g.z, dt, 1.8);

          // Apply spin around fixed world axis via quaternion
          _spinQuatTarget.setFromAxisAngle(SPIN_AXIS, spinRig.userData.yawGoal);
          _spinQuatCurrent.copy(spinRig.quaternion);
          // critically-damped slerp toward target for smoothness
          spinRig.quaternion.slerp(_spinQuatTarget, Math.min(1, dt * 6.0));

          if (enableFinalMotion || finalBlend>0){
            const mix = enableFinalMotion?1:finalBlend;
            molecule.rotation.y += 0.00175*mix;
            molecule.rotation.x += Math.sin(time*0.8)*0.0012*mix;
            molecule.rotation.z += Math.cos(time*0.6)*0.0008*mix;
            atoms.forEach((a,i)=>{const base=a.userData.baseScale; const vib=Math.sin(time*1.2+i*0.8)*0.002*mix; a.scale.setScalar(base+vib);});
            const cb = Math.sin(time*0.9)*0.003*mix; center.scale.setScalar(center.userData.baseScale + cb);
          }

          scene.updateMatrixWorld(true);
          bonds.forEach(positionCenterBond);
          renderer.render(scene,camera);
          rafId=requestAnimationFrame(render);
        }
        rafId=requestAnimationFrame(render);

        // Resize
        function onResize(){
          const rect=heroEl.getBoundingClientRect(); const w=Math.max(1,rect.width|0); const h=Math.max(1,rect.height|0);
          const isCoarse = matchMedia("(pointer: coarse)").matches; const dprCap=isCoarse?1.75:2.0;
          const nextDpr=Math.min(window.devicePixelRatio||1,dprCap);
          if (renderer.getPixelRatio()!==nextDpr) renderer.setPixelRatio(nextDpr);
          camera.aspect=w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h,false); updateCameraForViewport();
          if (window.ScrollTrigger) ScrollTrigger.refresh();
        }
        addEventListener("resize", onResize, {passive:true}); addEventListener("orientationchange", onResize);
        addEventListener("pageshow", e=>{if(e.persisted) onResize();},{passive:true}); onResize();

        // === Spin-only GSAP timeline (exactly one 360°; ease:none)
        if (window.gsap && window.ScrollTrigger){
          gsap.ticker.lagSmoothing(0);
          const tl = gsap.timeline({
            defaults:{ease:"none"},
            scrollTrigger:{
              trigger:heroEl, start:"top top", end:"+=120%", scrub:1, pin:true, anticipatePin:1,
              onUpdate:self=>{
                if (!isFinalized && self.progress>=0.999){
                  // capture state; idle motion after unpin
                  center.userData.baseScale = center.scale.x;
                  atoms.forEach(a=>a.userData.baseScale=a.scale.x);
                  isFinalized=true; enableFinalMotion=!self.isActive;
                }
                enableFinalMotion = isFinalized && !self.isActive;
                // a tiny pre-spin just before release to avoid stall
                finalBlend = self.isActive ? Math.max(0,(self.progress-0.97)/0.03) : 0;
              },
              onEnter:()=>{ if(!rafId) rafId=requestAnimationFrame(render); finalBlend=0; enableFinalMotion=false; },
              onEnterBack:()=>{ if(!rafId) rafId=requestAnimationFrame(render); finalBlend=0; enableFinalMotion=false; },
              onLeave:()=>{ enableFinalMotion=true; finalBlend=0; },
              onLeaveBack:()=>{ enableFinalMotion=false; finalBlend=0; }
            }
          });

          const fullTurn = Math.PI * 2;
          tl.to(spinRig.userData, { yawGoal: `+=${fullTurn}`, duration: 1.0, ease: "none" }, 0);

          // keep x/z steady during the spin so start==end pose
        }

        // Hide poster and status
        setTimeout(()=>posterEl && posterEl.classList.add("hidden"),150);
        statusEl.textContent="Spin-only ready"; setTimeout(()=>statusEl.remove(),600);

      }catch(err){
        console.error("WebGL init failed:", err);
        statusEl.textContent="WebGL not supported. Showing poster.";
        if(rafId) cancelAnimationFrame(rafId);
      }
    </script>

    <script>
      // === Animated gradient BG (above bokeh; keep CSS fallback until first draw; pause on hidden)
      (function(){
        const TARGET=document.getElementById("hero"); if(!TARGET) return;
        const cvs=document.createElement("canvas"); const ctx=cvs.getContext("2d",{alpha:false});
        cvs.style.position="absolute"; cvs.style.inset="0"; cvs.style.zIndex="-1"; cvs.style.pointerEvents="none";
        TARGET.prepend(cvs);
        let w=0,h=0, ready=false, running=true;
        const COLOR_A="#031a30", COLOR_B="#104068";
        function resize(){ w=TARGET.clientWidth; h=TARGET.clientHeight; cvs.width=w; cvs.height=h; }
        function lerpColor(a,b,t){const ar=parseInt(a.substr(1,2),16),ag=parseInt(a.substr(3,2),16),ab=parseInt(a.substr(5,2),16);
          const br=parseInt(b.substr(1,2),16),bg=parseInt(b.substr(3,2),16),bb=parseInt(b.substr(5,2),16);
          const r=Math.round(ar+(br-ar)*t), g=Math.round(ag+(bg-ag)*t), bl=Math.round(ab+(bb-ab)*t); return `rgb(${r},${g},${bl})`; }
        function draw(t){
          const time=t*0.003, angle=time*0.05, cx=w/2, cy=h/2, len=Math.sqrt(w*w+h*h)/2;
          const x0=cx+Math.cos(angle)*len, y0=cy+Math.sin(angle)*len, x1=cx-Math.cos(angle)*len, y1=cy-Math.sin(angle)*len;
          const grad=ctx.createLinearGradient(x0,y0,x1,y1);
          grad.addColorStop(0, COLOR_A);
          grad.addColorStop(0.5+0.2*Math.sin(time*0.5), lerpColor(COLOR_A,COLOR_B,0.5));
          grad.addColorStop(1, COLOR_B);
          ctx.fillStyle=grad; ctx.fillRect(0,0,w,h);
          if(!ready){ TARGET.style.background="transparent"; ready=true; }
        }
        function loop(t){ if(!running){ requestAnimationFrame(loop); return; } draw(t); requestAnimationFrame(loop); }
        resize(); requestAnimationFrame(loop); addEventListener("resize", resize);
        document.addEventListener("visibilitychange", ()=>{running=!document.hidden;});
      })();
    </script>
  </body>
</html>
