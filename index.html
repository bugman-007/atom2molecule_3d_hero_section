<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <meta name="color-scheme" content="light dark" />
    <title>Chematek Hero – Bonds + Pin</title>
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin />
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
        margin: 0;
      }
      body {
        background: #0a2746;
        color: #e8eef6;
        font-family: system-ui, Arial, sans-serif;
      }
      :root {
        --vh: 1vh;
      }
      #hero {
        position: relative;
        width: 100%;
        height: 100dvh;
        height: calc(var(--vh) * 100);
        overflow: hidden;
        overscroll-behavior: contain;
        background: radial-gradient(
          120% 120% at 30% 20%,
          #0e3969 0%,
          #06223d 60%,
          #051c33 100%
        );
      }
      #hero canvas {
        display: block;
        width: 100%;
        height: 100%;
      }
      .poster {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        filter: saturate(0.9) brightness(1.05);
      }
      .poster.hidden {
        display: none;
      }
      .status {
        position: absolute;
        inset: auto 0 1rem 0;
        text-align: center;
        font-size: 0.9rem;
        opacity: 0.7;
        pointer-events: none;
      }
      /* Copy overlays (left headline, right paragraph) */
      .copy {
        position: absolute;
        max-width: 44ch;
        line-height: 1.1;
        letter-spacing: 0.02em;
        text-wrap: balance;
      }
      #copy1 {
        left: 4vw;
        top: 22vh;
        font-weight: 800;
        font-size: clamp(26px, 5vw, 52px);
        color: #e9eef6;
      }
      #copy2 {
        right: 5vw;
        top: 28vh;
        font-weight: 500;
        font-size: clamp(14px, 1.6vw, 18px);
        color: #d9e3ef;
        opacity: 0;
        pointer-events: none;
      }

      /* After section ensures we can test scroll + pin behavior */
      #after {
        min-height: 200vh;
        display: grid;
        place-items: center;
        background: linear-gradient(180deg, #051c33 0%, #0a2746 100%);
      }
    </style>
  </head>
  <body>
    <section id="hero" aria-label="Hero 3D stage">
      <img
        class="poster"
        alt="Molecule hero poster"
        src="data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1200' height='800'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop stop-color='%230e3969'/%3E%3Cstop offset='1' stop-color='%23051c33'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect fill='url(%23g)' width='1200' height='800'/%3E%3C/svg%3E"
      />
      <div class="status" id="status">Bonds + Pin setup…</div>
      <div id="copy1">/ IN THE<br />PURSUIT OF<br />PROGRESS</div>
      <div id="copy2">
        Chematek is an industrial technology company that offers products,
        services, and solutions for chemicals, lubricants and engineering,
        procurement, and construction.
      </div>
    </section>
    <section id="after">
      <div>Scroll past the pinned hero to verify release behavior.</div>
    </section>

    <!-- Libraries (pinned) -->
    <script src="./assets/vendor/gsap.min.js"></script>
    <script src="./assets/vendor/ScrollTrigger.min.js"></script>
    <script type="module">
      import * as THREE from "./assets/vendor/three.module.min.js";

      // --- Mobile viewport stability ---
      (function setVH() {
        const set = () =>
          document.documentElement.style.setProperty(
            "--vh",
            window.innerHeight * 0.01 + "px"
          );
        set();
        addEventListener("resize", set, { passive: true });
        addEventListener("orientationchange", set);
      })();

      const heroEl = document.getElementById("hero");
      const statusEl = document.getElementById("status");
      const posterEl = document.querySelector(".poster");

      let renderer, scene, camera, molecule, rafId;

      try {
        // Renderer with DPR cap
        renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: false,
          powerPreference: "high-performance",
        });
        const isCoarse = matchMedia("(pointer: coarse)").matches;
        const dprCap = isCoarse ? 1.75 : 2.0;
        renderer.setPixelRatio(Math.min(devicePixelRatio || 1, dprCap));
        renderer.setSize(heroEl.clientWidth, heroEl.clientHeight, false);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.NoToneMapping;
        renderer.setClearColor(0x053b6c, 1);
        heroEl.prepend(renderer.domElement);

        // Scene & camera
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x053b6c);
        camera = new THREE.PerspectiveCamera(
          35,
          heroEl.clientWidth / heroEl.clientHeight,
          0.1,
          100
        );
        camera.position.set(0, 0, 8);

        // Fixed lighting (never animate)
        const key = new THREE.DirectionalLight(0xffffff, 1.05);
        key.position.set(2.2, 3.0, 4.0);
        const rim = new THREE.DirectionalLight(0xaecbff, 0.38);
        rim.position.set(-3.0, 1.2, -2.2);
        const amb = new THREE.AmbientLight(0xffffff, 0.18);
        scene.add(key, rim, amb);

        // Materials
        const atomMat = new THREE.MeshPhysicalMaterial({
          color: 0x2c5aa0,
          roughness: 0.25,
          metalness: 0.05,
          clearcoat: 0.85,
          clearcoatRoughness: 0.25,
          transmission: 0.35, // ← glass-like without changing hue
          thickness: 0.6,
          ior: 1.45,
          attenuationColor: 0x2c5aa0,
          attenuationDistance: 8,
          transparent: true,
        });
        const bondMat = new THREE.MeshPhysicalMaterial({
          color: 0x87a9d8,
          roughness: 0.35,
          metalness: 0.05,
          clearcoat: 0.5,
          clearcoatRoughness: 0.35,
          transmission: 0.25,
          thickness: 0.5,
          ior: 1.45,
          transparent: true,
        });
        atomMat.transparent = true;
        bondMat.transparent = true;
        // atomMat.depthWrite = false;
        // bondMat.depthWrite = false;

        // Deterministic random so the initial scatter is stable per reload
        function seeded(i) {
          return Math.sin(i * 16807.123) % 1;
        }
        function rand(i, min, max) {
          const r = Math.abs(seeded(i));
          return min + r * (max - min);
        }

        const baseRadius = 0.5;

        // Root for everything in the molecule hero
        molecule = new THREE.Group();
        scene.add(molecule);

        const masterSurface = new THREE.Group(); // local Y ⟂ MASTERSURFACE
        molecule.add(masterSurface);

        const centerGroup = new THREE.Group();
        const ringGroup = new THREE.Group();
        masterSurface.add(centerGroup, ringGroup);
        masterSurface.rotation.set(Math.PI / 1.5, -0.2, 0.0);

        // Geometry radius must match baseRadius so bond halves start at the true surface
        const atomGeo = new THREE.SphereGeometry(baseRadius, 48, 48);

        // Central atom: fixed position & constant scale (storyboard panel 1)
        const center = new THREE.Mesh(atomGeo, atomMat);
        center.position.set(0, 0, 0);
        center.scale.setScalar(1); // constant; no growth/tween
        centerGroup.add(center);
        center.renderOrder = 0;

        // Outer atoms (A..E) placed ON the MASTERSURFACE plane (z=0 in its local space).
        // Depth differences now come from the plane tilt (PATCH A), not per-atom Z.
        const Rplane = 2.2; // ring radius in the MASTERSURFACE plane
        const baseAngle = Math.PI / 2; // A at top
        const step = (2 * Math.PI) / 5;

        const startRing = Array.from({ length: 5 }, (_, i) => {
          const ang = baseAngle - i * step; // A,B,C,D,E around the circle
          return new THREE.Vector3(
            Math.cos(ang) * Rplane,
            Math.sin(ang) * Rplane,
            0
          );
        });

        const atoms = [
          { id: "A" },
          { id: "B" },
          { id: "C" },
          { id: "D" },
          { id: "E" },
        ].map((d, i) => {
          const m = new THREE.Mesh(atomGeo, atomMat);
          m.position.copy(startRing[i]); // A..E with planned depths
          m.scale.setScalar(1); // no growth now (you disabled growth phase)
          ringGroup.add(m);
          m.renderOrder = 2;
          return m;
        });

        // --- Targets & via control points (for assembly) ---
        // Snapshot *after* random spawn so we can tween from these
        const startPositions = atoms.map((m) => m.position.clone());

        // Trigonal-bipyramidal (non-coplanar) targets: 2 axial (±Z), 3 equatorial (XY @ 120°)
        const R = 1.8; // equal bond length to center
        const targets = [
          new THREE.Vector3(0.0, 0.0, R), // 0 (A) axial front
          new THREE.Vector3(0.0, 0.0, -R), // 1 (B) axial back
          new THREE.Vector3(0.0, R, 0.0), // 2 (C) equatorial
          new THREE.Vector3(
            R * Math.cos(-Math.PI / 6), // 3 (D) equatorial
            R * Math.sin(-Math.PI / 6),
            0.0
          ),
          new THREE.Vector3(
            R * Math.cos((7 * Math.PI) / 6), // 4 (E) equatorial
            R * Math.sin((7 * Math.PI) / 6),
            0.0
          ),
        ];

        // Gentle 3D approach arcs (keep Z modest; axial paths bow toward ±Z)
        const vias = {
          0: new THREE.Vector3(
            startPositions[0].x * 0.6,
            startPositions[0].y * 0.6,
            R * 0.4
          ),
          1: new THREE.Vector3(
            startPositions[1].x * 0.6,
            startPositions[1].y * 0.6,
            -R * 0.4
          ),
          2: new THREE.Vector3(targets[2].x * 0.6, targets[2].y * 0.6, -0.22),
          3: new THREE.Vector3(targets[3].x * 0.6, targets[3].y * 0.6, 0.22),
          4: new THREE.Vector3(targets[4].x * 0.6, targets[4].y * 0.6, -0.18),
        };

        // Bond / cap dimensions (keep caps slightly fuller than the rod for a meniscus look)
        const bondRadius = 0.12;
        const halfGeo = new THREE.CylinderGeometry(
          bondRadius,
          bondRadius,
          1,
          24
        );
        halfGeo.translate(0, 0.5, 0);

        // Meniscus/fillet: a small sphere used as a cap at each sphere↔rod interface
        const capGeo = new THREE.SphereGeometry(bondRadius * 1.15, 24, 18);

        const bonds = []; // { a, b, capA, capB, growth, outerIdx }

        function createCenterBond(outerIdx) {
          const aHalf = new THREE.Mesh(halfGeo, bondMat); // center-side half
          const bHalf = new THREE.Mesh(halfGeo, bondMat); // outer-side half
          aHalf.visible = bHalf.visible = false;
          // Parent halves to molecule root so they aren’t double-transformed
          molecule.add(aHalf, bHalf);

          // Meniscus caps (center-side & outer-side)
          const capC = new THREE.Mesh(capGeo, bondMat);
          const capO = new THREE.Mesh(capGeo, bondMat);
          capC.visible = capO.visible = false;
          molecule.add(capC, capO);

          // Keep glass draw order stable: center → bonds/caps → outers
          aHalf.renderOrder = bHalf.renderOrder = 1;
          capC.renderOrder = capO.renderOrder = 1;

          const pair = {
            a: aHalf,
            b: bHalf,
            capA: capC,
            capB: capO,
            growth: 0,
            outerIdx,
          };
          bonds.push(pair);
          return pair;
        }

        // Create five center↔outer bonds (order will be handled by the timeline)
        createCenterBond(0);
        createCenterBond(1);
        createCenterBond(2);
        createCenterBond(3);
        createCenterBond(4);
        for (const b of bonds) {
          b.growth = 0;
          b.a.visible = b.b.visible = false;
        }

        const UP = new THREE.Vector3(0, 1, 0);
        const tmpDir = new THREE.Vector3();

        // Bonds should be present the whole time for this storyboard phase

        // temp vectors reused each call
        const tmpCw = new THREE.Vector3(); // center world
        const tmpOw = new THREE.Vector3(); // outer world
        const tmpCl = new THREE.Vector3(); // center in molecule space
        const tmpOl = new THREE.Vector3(); // outer in molecule space

        function positionCenterBond(pair) {
          // 1) sample **world** positions
          center.getWorldPosition(tmpCw);
          atoms[pair.outerIdx].getWorldPosition(tmpOw);

          // 2) convert to the bond's parent space (molecule)
          tmpCl.copy(tmpCw);
          molecule.worldToLocal(tmpCl);
          tmpOl.copy(tmpOw);
          molecule.worldToLocal(tmpOl);

          // 3) direction & distances in **molecule space**
          tmpDir.subVectors(tmpOl, tmpCl);
          const centerDist = tmpDir.length();
          const g = pair.growth;

          const rC = baseRadius * center.scale.x;
          const rO = baseRadius * atoms[pair.outerIdx].scale.x;

          const coreLen = Math.max(0, centerDist - (rC + rO));
          const halfLen = coreLen * 0.5;

          if (halfLen <= 1e-6 || g <= 0) {
            pair.a.visible = pair.b.visible = false;
            return;
          }

          const dir = tmpDir.clone().normalize();

          // Center-side half (aiming outward from **tmpCl**)
          pair.a.visible = true;
          pair.a.position.copy(tmpCl).add(dir.clone().multiplyScalar(rC));
          pair.a.quaternion.setFromUnitVectors(UP, dir);
          pair.a.scale.set(1, halfLen * g, 1);

          // Outer-side half (aiming inward from **tmpOl**)
          pair.b.visible = true;
          pair.b.position.copy(tmpOl).add(dir.clone().multiplyScalar(-rO));
          const neg = dir.clone().multiplyScalar(-1);
          pair.b.quaternion.setFromUnitVectors(UP, neg);
          pair.b.scale.set(1, halfLen * g, 1);

          // Meniscus caps at each interface (visible once growth begins)
          const showCap = g > 0.001;

          // Place caps right where the rod meets each sphere surface
          pair.capA.visible = showCap;
          pair.capA.position.copy(tmpCl).add(dir.clone().multiplyScalar(rC));

          pair.capB.visible = showCap;
          pair.capB.position.copy(tmpOl).add(dir.clone().multiplyScalar(-rO));
        }

        function moveAlongQuadratic(atomIdx, p0, p1, p2, tl, dur, at) {
          const proxy = { t: 0 };
          tl.to(
            proxy,
            {
              t: 1,
              duration: dur,
              ease: "power2.out",
              onUpdate: () => {
                const t = proxy.t,
                  it = 1 - t;
                const x = it * it * p0.x + 2 * it * t * p1.x + t * t * p2.x;
                const y = it * it * p0.y + 2 * it * t * p1.y + t * t * p2.y;
                const z = it * it * p0.z + 2 * it * t * p1.z + t * t * p2.z;
                atoms[atomIdx].position.set(x, y, z);
              },
            },
            at
          );
        }

        // Micro-drift (very subtle, no Z)
        let t = 0;
        function render() {
          t += 0.01;

          // No drift (per spec) — atoms stay fixed unless GSAP rotates the ring
          // Ensure transforms from GSAP are applied before we read positions
          scene.updateMatrixWorld(true);

          // Keep bonds glued to both ends every frame
          for (let i = 0; i < bonds.length; i++) positionCenterBond(bonds[i]);

          // Draw and schedule next frame
          renderer.render(scene, camera);
          rafId = requestAnimationFrame(render);
        }
        rafId = requestAnimationFrame(render);

        // Resize/orientation
        let resizeRAF;
        const onResize = () => {
          // Use rect to avoid stale clientWidth during pin/unpin
          const rect = heroEl.getBoundingClientRect();
          const w = Math.max(1, Math.floor(rect.width));
          const h = Math.max(1, Math.floor(rect.height));

          // DPR can change with zoom/orientation; recalc and cap
          const isCoarse = matchMedia("(pointer: coarse)").matches;
          const dprCap = isCoarse ? 1.75 : 2.0;
          const nextDpr = Math.min(window.devicePixelRatio || 1, dprCap);
          if (renderer.getPixelRatio() !== nextDpr)
            renderer.setPixelRatio(nextDpr);

          // Camera + renderer viewport
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
          renderer.setSize(w, h, false);

          // Recompute ScrollTrigger measurements after layout settles
          if (window.ScrollTrigger) {
            cancelAnimationFrame(resizeRAF);
            resizeRAF = requestAnimationFrame(() => ScrollTrigger.refresh());
          }
        };
        addEventListener("resize", onResize, { passive: true });
        addEventListener("orientationchange", onResize);
        // Safari bfcache + mobile re-activation can yield stale sizes
        addEventListener(
          "pageshow",
          (e) => {
            if (e.persisted) onResize();
          },
          { passive: true }
        );
        onResize();

        // Master GSAP timeline: pin + scrub + assembly + orbit
        // Master GSAP timeline: pin + scrub + single-step rotation (A→B→C→D→E→A)
        if (window.gsap && window.ScrollTrigger) {
          // Master GSAP timeline: full 3D rotation + sequential bond joins
          const tl = gsap.timeline({
            defaults: { ease: "none" },
            scrollTrigger: {
              trigger: "#hero",
              start: "top top",
              end: "+=180%",
              scrub: true,
              pin: true,
              // markers: true,
            },
          });

          // 3D spin over the whole scroll: yaw 360°, gentle pitch/roll that return to start
          const yawTurn = Math.PI * 2;
          tl.to(masterSurface.rotation, { y: "+=" + yawTurn, duration: 1 }, 0);
          tl.to(
            masterSurface.rotation,
            { x: "+=0.28", z: "-=0.22", duration: 0.5, ease: "sine.inOut" },
            0
          );
          tl.to(
            masterSurface.rotation,
            { x: "-=0.28", z: "+=0.22", duration: 0.5, ease: "sine.inOut" },
            0.5
          );

          // Sequential joins: five equal beats across the scroll
          const beat = 1 / 5;
          const moveDur = beat * 1.2;
          moveAlongQuadratic(
            0,
            startPositions[0],
            vias[0],
            targets[0],
            tl,
            moveDur,
            0 * beat
          );
          moveAlongQuadratic(
            1,
            startPositions[1],
            vias[1],
            targets[1],
            tl,
            moveDur,
            1 * beat
          );
          moveAlongQuadratic(
            2,
            startPositions[2],
            vias[2],
            targets[2],
            tl,
            moveDur,
            2 * beat
          );
          moveAlongQuadratic(
            3,
            startPositions[3],
            vias[3],
            targets[3],
            tl,
            moveDur,
            3 * beat
          );
          moveAlongQuadratic(
            4,
            startPositions[4],
            vias[4],
            targets[4],
            tl,
            moveDur,
            4 * beat
          );
          tl.to(
            bonds[0],
            {
              growth: 1,
              duration: beat * 0.9,
              ease: "power2.out",
              onStart: () => {
                bonds[0].a.visible = bonds[0].b.visible = true;
              },
            },
            0 * beat + beat * 0.7
          );
          tl.to(
            bonds[1],
            {
              growth: 1,
              duration: beat * 0.9,
              ease: "power2.out",
              onStart: () => {
                bonds[1].a.visible = bonds[1].b.visible = true;
              },
            },
            1 * beat + beat * 0.7
          );
          tl.to(
            bonds[2],
            {
              growth: 1,
              duration: beat * 0.9,
              ease: "power2.out",
              onStart: () => {
                bonds[2].a.visible = bonds[2].b.visible = true;
              },
            },
            2 * beat + beat * 0.7
          );
          tl.to(
            bonds[3],
            {
              growth: 1,
              duration: beat * 0.9,
              ease: "power2.out",
              onStart: () => {
                bonds[3].a.visible = bonds[3].b.visible = true;
              },
            },
            3 * beat + beat * 0.7
          );
          tl.to(
            bonds[4],
            {
              growth: 1,
              duration: beat * 0.9,
              ease: "power2.out",
              onStart: () => {
                bonds[4].a.visible = bonds[4].b.visible = true;
              },
            },
            4 * beat + beat * 0.7
          );
        }
        // Hide poster once rendering is alive
        setTimeout(() => posterEl && posterEl.classList.add("hidden"), 150);
        statusEl.textContent = "Bonds visible + section pinned";
        setTimeout(() => statusEl.remove(), 700);
      } catch (err) {
        console.error("WebGL init failed:", err);
        statusEl.textContent = "WebGL not supported. Showing poster.";
        if (rafId) cancelAnimationFrame(rafId);
      }
    </script>
  </body>
</html>
