<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <meta name="color-scheme" content="light dark" />
    <title>Chematek Hero – Bonds + Pin</title>
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin />
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
        margin: 0;
      }
      body {
        background: #0a2746;
        color: #e8eef6;
        font-family: system-ui, Arial, sans-serif;
      }
      :root {
        --vh: 1vh;
      }
      #hero {
        position: relative;
        width: 100%;
        height: 100dvh;
        height: calc(var(--vh) * 100);
        overflow: hidden;
        overscroll-behavior: contain;
        background: radial-gradient(
          120% 120% at 30% 20%,
          #0e3969 0%,
          #06223d 60%,
          #051c33 100%
        );
      }
      #hero canvas {
        display: block;
        width: 100%;
        height: 100%;
      }
      .poster {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        filter: saturate(0.9) brightness(1.05);
      }
      .poster.hidden {
        display: none;
      }
      .status {
        position: absolute;
        inset: auto 0 1rem 0;
        text-align: center;
        font-size: 0.9rem;
        opacity: 0.7;
        pointer-events: none;
      }
      /* Copy overlays (left headline, right paragraph) */
      .copy {
        position: absolute;
        max-width: 44ch;
        line-height: 1.1;
        letter-spacing: 0.02em;
        text-wrap: balance;
      }
      #copy1 {
        left: 4vw;
        top: 22vh;
        font-weight: 800;
        font-size: clamp(26px, 5vw, 52px);
        color: #e9eef6;
      }
      #copy2 {
        right: 5vw;
        top: 28vh;
        font-weight: 500;
        font-size: clamp(14px, 1.6vw, 18px);
        color: #d9e3ef;
        opacity: 0;
        pointer-events: none;
      }

      /* After section ensures we can test scroll + pin behavior */
      #after {
        min-height: 200vh;
        display: grid;
        place-items: center;
        background: linear-gradient(180deg, #051c33 0%, #0a2746 100%);
      }
    </style>
  </head>
  <body>
    <section id="hero" aria-label="Hero 3D stage">
      <img
        class="poster"
        alt="Molecule hero poster"
        src="data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1200' height='800'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop stop-color='%230e3969'/%3E%3Cstop offset='1' stop-color='%23051c33'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect fill='url(%23g)' width='1200' height='800'/%3E%3C/svg%3E"
      />
      <div class="status" id="status">Bonds + Pin setup…</div>
      <div id="copy1">/ IN THE<br />PURSUIT OF<br />PROGRESS</div>
      <div id="copy2">
        Chematek is an industrial technology company that offers products,
        services, and solutions for chemicals, lubricants and engineering,
        procurement, and construction.
      </div>
    </section>
    <section id="after">
      <div>Scroll past the pinned hero to verify release behavior.</div>
    </section>

    <!-- Libraries (pinned) -->
    <script src="./assets/vendor/gsap.min.js"></script>
    <script src="./assets/vendor/ScrollTrigger.min.js"></script>
    <script type="module">
      import * as THREE from "./assets/vendor/three.module.min.js";

      // --- Mobile viewport stability ---
      (function setVH() {
        const set = () =>
          document.documentElement.style.setProperty(
            "--vh",
            window.innerHeight * 0.01 + "px"
          );
        set();
        addEventListener("resize", set, { passive: true });
        addEventListener("orientationchange", set);
      })();

      const heroEl = document.getElementById("hero");
      const statusEl = document.getElementById("status");
      const posterEl = document.querySelector(".poster");

      let renderer, scene, camera, molecule, rafId;

      try {
        // Renderer with DPR cap
        renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: false,
          powerPreference: "high-performance",
        });
        const isCoarse = matchMedia("(pointer: coarse)").matches;
        const dprCap = isCoarse ? 1.75 : 2.0;
        renderer.setPixelRatio(Math.min(devicePixelRatio || 1, dprCap));
        renderer.setSize(heroEl.clientWidth, heroEl.clientHeight, false);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.NoToneMapping;
        renderer.setClearColor(0x053b6c, 1);
        heroEl.prepend(renderer.domElement);

        // Scene & camera
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x053b6c);
        camera = new THREE.PerspectiveCamera(
          35,
          heroEl.clientWidth / heroEl.clientHeight,
          0.1,
          100
        );
        camera.position.set(0, 0, 8);

        // Fixed lighting (never animate)
        const key = new THREE.DirectionalLight(0xffffff, 1.05);
        key.position.set(2.2, 3.0, 4.0);
        const rim = new THREE.DirectionalLight(0xaecbff, 0.38);
        rim.position.set(-3.0, 1.2, -2.2);
        const amb = new THREE.AmbientLight(0xffffff, 0.18);
        scene.add(key, rim, amb);

        // Materials
        const atomMat = new THREE.MeshPhysicalMaterial({
          color: 0x2c5aa0,
          roughness: 0.28,
          metalness: 0.08,
          clearcoat: 0.6,
          clearcoatRoughness: 0.4,
        });
        const bondMat = new THREE.MeshPhysicalMaterial({
          color: 0x87a9d8,
          roughness: 0.35,
          metalness: 0.05,
          clearcoat: 0.3,
          clearcoatRoughness: 0.5,
        });

        // Deterministic random so the initial scatter is stable per reload
        function seeded(i) {
          return Math.sin(i * 16807.123) % 1;
        }
        function rand(i, min, max) {
          const r = Math.abs(seeded(i));
          return min + r * (max - min);
        }

        const baseRadius = 0.5;
        // --- Atoms (initial state) ---
        molecule = new THREE.Group();
        scene.add(molecule);
        molecule.position.x = 1.2; // kept for later copy swap
        const centerGroup = new THREE.Group();
        const ringGroup = new THREE.Group();
        molecule.add(centerGroup, ringGroup);

        // Geometry radius must match baseRadius so bond halves start at the true surface
        const atomGeo = new THREE.SphereGeometry(baseRadius, 48, 48);

        // Central atom: fixed position & constant scale (storyboard panel 1)
        const center = new THREE.Mesh(atomGeo, atomMat);
        center.position.set(0, 0, 0);
        center.scale.setScalar(1); // constant; no growth/tween
        centerGroup.add(center);

        // Outer atoms (still start small; will grow 0.35 → 1 during assembly)
        const atoms = [
          { id: "A", pos: new THREE.Vector3(-3.0, 0.5, 0.0), phase: 0.0 },
          { id: "B", pos: new THREE.Vector3(3.0, -0.2, 0.0), phase: 0.73 },
          { id: "C", pos: new THREE.Vector3(0.0, 2.2, 0.0), phase: 1.31 },
          { id: "D", pos: new THREE.Vector3(0.0, -2.2, 0.0), phase: 2.07 },
          { id: "E", pos: new THREE.Vector3(2.2, 1.4, 0.0), phase: 4.66 }, // new
        ].map((d) => {
          const m = new THREE.Mesh(atomGeo, atomMat);
          m.position.copy(d.pos);
          m.scale.setScalar(0.35); // <-- start small so we can grow 0.35 → 1.0
          m.userData.phase = d.phase;
          ringGroup.add(m);
          return m;
        });
        // --- Targets & via control points (for assembly) ---
        // Snapshot *after* random spawn so we can tween from these
        const startPositions = atoms.map((m) => m.position.clone());

        // Regular pentagon radius → equal center-to-center distances
        const R = 1.8; // ring radius (works well with baseRadius=0.1 and camera z=8)
        const sin36 = 0.5877852522924731,
          cos36 = 0.8090169943749475;
        const targets = [
          new THREE.Vector3(0.0, R, 0.0), // 0 top
          new THREE.Vector3(sin36 * R, cos36 * R, 0.0), // 1
          new THREE.Vector3(sin36 * R, -cos36 * R, 0.0), // 2
          new THREE.Vector3(-sin36 * R, -cos36 * R, 0.0), // 3
          new THREE.Vector3(-sin36 * R, cos36 * R, 0.0), // 4
        ];

        // Gentle approach arcs (shallow Z for comfort)
        const vias = {
          0: new THREE.Vector3(0.3, R * 0.75, 0.25),
          1: new THREE.Vector3(R * 0.9, 0.6, 0.35),
          2: new THREE.Vector3(R * 0.5, -0.9, -0.3),
          3: new THREE.Vector3(-R * 0.5, -0.9, 0.25),
          4: new THREE.Vector3(-R * 0.9, 0.6, -0.3),
        };

        // Bonds (two halves per connection; growth from each atom’s surface toward center)
        const halfGeo = new THREE.CylinderGeometry(0.12, 0.12, 1, 24);
        halfGeo.translate(0, 0.5, 0);
        const bonds = []; // array of { a:Mesh, b:Mesh, growth:number, outerIdx:number }

        function createCenterBond(outerIdx) {
          const aHalf = new THREE.Mesh(halfGeo, bondMat); // center-side half
          const bHalf = new THREE.Mesh(halfGeo, bondMat); // outer-side half
          aHalf.visible = bHalf.visible = false;
          // Parent halves to molecule root so they aren’t double-transformed
          molecule.add(aHalf, bHalf);
          
          const pair = { a: aHalf, b: bHalf, growth: 0, outerIdx };
          bonds.push(pair);
          return pair;
        }

        // Create five center↔outer bonds (order will be handled by the timeline)
        createCenterBond(0);
        createCenterBond(1);
        createCenterBond(2);
        createCenterBond(3);
        createCenterBond(4);

        const UP = new THREE.Vector3(0, 1, 0);
        const tmpDir = new THREE.Vector3();

        // temp vectors reused each call
        const tmpCw = new THREE.Vector3(); // center world
        const tmpOw = new THREE.Vector3(); // outer world
        const tmpCl = new THREE.Vector3(); // center in molecule space
        const tmpOl = new THREE.Vector3(); // outer in molecule space

        function positionCenterBond(pair) {
          // 1) sample **world** positions
          center.getWorldPosition(tmpCw);
          atoms[pair.outerIdx].getWorldPosition(tmpOw);

          // 2) convert to the bond's parent space (molecule)
          tmpCl.copy(tmpCw);
          molecule.worldToLocal(tmpCl);
          tmpOl.copy(tmpOw);
          molecule.worldToLocal(tmpOl);

          // 3) direction & distances in **molecule space**
          tmpDir.subVectors(tmpOl, tmpCl);
          const centerDist = tmpDir.length();
          const g = pair.growth;

          const rC = baseRadius * center.scale.x;
          const rO = baseRadius * atoms[pair.outerIdx].scale.x;

          const coreLen = Math.max(0, centerDist - (rC + rO));
          const halfLen = coreLen * 0.5;

          if (halfLen <= 1e-6 || g <= 0) {
            pair.a.visible = pair.b.visible = false;
            return;
          }

          const dir = tmpDir.clone().normalize();

          // Center-side half (aiming outward from **tmpCl**)
          pair.a.visible = true;
          pair.a.position.copy(tmpCl).add(dir.clone().multiplyScalar(rC));
          pair.a.quaternion.setFromUnitVectors(UP, dir);
          pair.a.scale.set(1, halfLen * g, 1);

          // Outer-side half (aiming inward from **tmpOl**)
          pair.b.visible = true;
          pair.b.position.copy(tmpOl).add(dir.clone().multiplyScalar(-rO));
          const neg = dir.clone().multiplyScalar(-1);
          pair.b.quaternion.setFromUnitVectors(UP, neg);
          pair.b.scale.set(1, halfLen * g, 1);
        }

        function moveAlongQuadratic(atomIdx, p0, p1, p2, tl, dur, at) {
          const proxy = { t: 0 };
          tl.to(
            proxy,
            {
              t: 1,
              duration: dur,
              ease: "power2.out",
              onUpdate: () => {
                const t = proxy.t,
                  it = 1 - t;
                const x = it * it * p0.x + 2 * it * t * p1.x + t * t * p2.x;
                const y = it * it * p0.y + 2 * it * t * p1.y + t * t * p2.y;
                const z = it * it * p0.z + 2 * it * t * p1.z + t * t * p2.z;
                atoms[atomIdx].position.set(x, y, z);
              },
            },
            at
          );
        }

        // Micro-drift (very subtle, no Z)
        let t = 0;
        let driftAmpX = 0.0025,
          driftAmpY = 0.002; // << add amplitudes
        function render() {
          t += 0.01;

          // subtle drift
          for (let i = 0; i < atoms.length; i++) {
            const m = atoms[i];
            const ph = m.userData.phase || 0;
            m.position.x += Math.sin(t * 0.52 + ph) * driftAmpX;
            m.position.y += Math.sin(t * 0.37 + ph * 1.33) * driftAmpY;
          }

          // **Ensure world matrices reflect GSAP rotations before sampling positions**
          scene.updateMatrixWorld(true);

          // bonds follow actual world positions
          for (let i = 0; i < bonds.length; i++) positionCenterBond(bonds[i]);

          renderer.render(scene, camera);
          rafId = requestAnimationFrame(render);
        }
        rafId = requestAnimationFrame(render);

        // Resize/orientation
        let resizeRAF;
        const onResize = () => {
          // Use rect to avoid stale clientWidth during pin/unpin
          const rect = heroEl.getBoundingClientRect();
          const w = Math.max(1, Math.floor(rect.width));
          const h = Math.max(1, Math.floor(rect.height));

          // DPR can change with zoom/orientation; recalc and cap
          const isCoarse = matchMedia("(pointer: coarse)").matches;
          const dprCap = isCoarse ? 1.75 : 2.0;
          const nextDpr = Math.min(window.devicePixelRatio || 1, dprCap);
          if (renderer.getPixelRatio() !== nextDpr)
            renderer.setPixelRatio(nextDpr);

          // Camera + renderer viewport
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
          renderer.setSize(w, h, false);

          // Recompute ScrollTrigger measurements after layout settles
          if (window.ScrollTrigger) {
            cancelAnimationFrame(resizeRAF);
            resizeRAF = requestAnimationFrame(() => ScrollTrigger.refresh());
          }
        };
        addEventListener("resize", onResize, { passive: true });
        addEventListener("orientationchange", onResize);
        // Safari bfcache + mobile re-activation can yield stale sizes
        addEventListener(
          "pageshow",
          (e) => {
            if (e.persisted) onResize();
          },
          { passive: true }
        );

        // Master GSAP timeline: pin + scrub + assembly + orbit
        if (window.gsap && window.ScrollTrigger) {
          gsap.registerPlugin(ScrollTrigger);
          const tl = gsap.timeline({
            defaults: { ease: "power2.out" },
            scrollTrigger: {
              trigger: "#hero",
              start: "top top",
              end: "+=180%",
              scrub: true,
              pin: true,
              // markers: true,
            },
          });

          // Labels for clarity
          tl.addLabel("idle", 0.0)
            .addLabel("assemble", 0.25)
            .addLabel("orbit", 0.75)
            .addLabel("swap", 0.82); // when copy swaps and molecule relocates
          tl.add(() => {
            const d = (i, j) =>
              atoms[i].position.distanceTo(atoms[j].position).toFixed(3);
            console.log(
              "edge lengths:",
              d(0, 1),
              d(1, 2),
              d(2, 3),
              d(3, 4),
              d(4, 0)
            );
          }, "orbit");

          // Disable drift during precise pathing
          tl.add(() => {
            driftAmpX = 0;
            driftAmpY = 0;
          }, "assemble-=0.05");

          // Helper: move along curve and grow from 0.35 → 1 while traveling
          function moveAndGrow(i, at, durMove = 1.2, durGrow = 1.0) {
            moveAlongQuadratic(
              i,
              startPositions[i],
              vias[i],
              targets[i],
              tl,
              durMove,
              at
            );
            tl.to(
              atoms[i].scale,
              { x: 1, y: 1, z: 1, duration: durGrow, ease: "power2.out" },
              at
            );
          }

          // Staggered assembly
          moveAndGrow(0, "assemble");
          moveAndGrow(1, "assemble+=0.20");
          moveAndGrow(2, "assemble+=0.55");
          moveAndGrow(3, "assemble+=0.90");
          moveAndGrow(4, "assemble+=1.15");

          // Bonds: grow from both ends ~midway through their adjacent motion
          tl.to(
            bonds[0],
            {
              growth: 1,
              duration: 0.7,
              ease: "power2.out",
              onStart: () => {
                bonds[0].a.visible = bonds[0].b.visible = true;
              },
            },
            "assemble+=0.60"
          ); // 0-1
          tl.to(
            bonds[1],
            {
              growth: 1,
              duration: 0.7,
              ease: "power2.out",
              onStart: () => {
                bonds[1].a.visible = bonds[1].b.visible = true;
              },
            },
            "assemble+=0.95"
          ); // 1-2
          tl.to(
            bonds[2],
            {
              growth: 1,
              duration: 0.7,
              ease: "power2.out",
              onStart: () => {
                bonds[2].a.visible = bonds[2].b.visible = true;
              },
            },
            "assemble+=1.25"
          ); // 2-3
          tl.to(
            bonds[3],
            {
              growth: 1,
              duration: 0.7,
              ease: "power2.out",
              onStart: () => {
                bonds[3].a.visible = bonds[3].b.visible = true;
              },
            },
            "assemble+=1.40"
          ); // 3-4
          tl.to(
            bonds[4],
            {
              growth: 1,
              duration: 0.7,
              ease: "power2.out",
              onStart: () => {
                bonds[4].a.visible = bonds[4].b.visible = true;
              },
            },
            "assemble+=1.55"
          ); // 4-0

          // Re-introduce subtle drift once formed
          tl.add(() => {
            driftAmpX = 0.0015;
            driftAmpY = 0.0012;
          }, "orbit-=0.05");

          // Slow global orbit + shallow camera ellipse (lights remain fixed)
          tl.to(
            ringGroup.rotation,
            { y: "+=" + Math.PI * 0.6, duration: 2.5, ease: "none" },
            "orbit"
          );
          tl.to(
            camera.position,
            {
              x: 0.8,
              z: 8.6,
              duration: 2.5,
              ease: "sine.inOut",
              onUpdate: () => camera.lookAt(0, 0, 0),
            },
            "orbit"
          );

          // --- Copy + relocation per client ---
          // Fade out headline, slide molecule **into** that left space, fade in paragraph on right
          tl.to(
            "#copy1",
            { autoAlpha: 0, duration: 0.45, ease: "power1.out" },
            "swap"
          );
          tl.to(
            molecule.position,
            { x: -1.3, duration: 1.4, ease: "power2.inOut" },
            "swap"
          ); // move right → left
          tl.to(
            "#copy2",
            { autoAlpha: 1, duration: 0.55, ease: "power1.out" },
            "swap+=0.35"
          );
        }

        // Hide poster once rendering is alive
        setTimeout(() => posterEl && posterEl.classList.add("hidden"), 150);
        statusEl.textContent = "Bonds visible + section pinned";
        setTimeout(() => statusEl.remove(), 700);
      } catch (err) {
        console.error("WebGL init failed:", err);
        statusEl.textContent = "WebGL not supported. Showing poster.";
        if (rafId) cancelAnimationFrame(rafId);
      }
    </script>
  </body>
</html>
