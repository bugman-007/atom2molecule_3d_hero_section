<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <meta name="color-scheme" content="light dark" />
    <title>Chematek Hero — Bonds + Pin</title>
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin />
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
        margin: 0;
      }
      body {
        background: #0a2746;
        color: #e8eef6;
        font-family: system-ui, Arial, sans-serif;
      }
      :root {
        --vh: 1vh;
      }
      #hero {
        position: relative;
        width: 100%;
        height: 100dvh;
        height: calc(var(--vh) * 100);
        overflow: hidden;
        overscroll-behavior: contain;
        background: radial-gradient(
          120% 120% at 30% 20%,
          #0161ae 0%,
          #06223d 60%,
          #002c50 100%
        );
      }
      #hero canvas {
        display: block;
        width: 100%;
        height: 100%;
      }
      .poster {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        filter: saturate(0.9) brightness(1.05);
      }
      .poster.hidden {
        display: none;
      }
      .status {
        position: absolute;
        inset: auto 0 1rem 0;
        text-align: center;
        font-size: 0.9rem;
        opacity: 0.7;
        pointer-events: none;
      }
      .copy {
        position: absolute;
        max-width: 44ch;
        line-height: 1.1;
        letter-spacing: 0.02em;
        text-wrap: balance;
      }
      #copy1 {
        left: 10vw;
        top: 22vh;
        font-weight: 500;
        font-size: clamp(37px, 5vw, 80px);
        color: #e9eef6;
      }
      #copy2 {
        right: 5vw;
        top: 80vh;
        font-weight: 400;

        font-size: clamp(18px, 1.6vw, 24px);
        color: #d9e3ef;
        opacity: 0;
        pointer-events: none;
      }

      #after {
        min-height: 200vh;
        display: grid;
        place-items: center;
        background: linear-gradient(180deg, #051c33 0%, #0b0a46 100%);
      }
    </style>
  </head>
  <body>
    <section id="hero" aria-label="Hero 3D stage">
      <img
        class="poster"
        alt="Molecule hero poster"
        src="data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1200' height='800'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop stop-color='%230e3969'/%3E%3Cstop offset='1' stop-color='%23051c33'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect fill='url(%23g)' width='1200' height='800'/%3E%3C/svg%3E"
      />
      <div class="status" id="status">Bonds + Pin setup…</div>
      <div id="copy1" class="copy">
        /&thinsp;IN THE<br />&nbsp; PURSUIT OF<br />
        <span style="color: #f89a5f">&nbsp; PROGRESS</span>
      </div>
      <div id="copy2" class="copy">
        Chematek is an industrial technology company that offers products,
        services, and solutions for chemicals, lubricants and engineering,
        procurement, and construction.
      </div>
    </section>
    <section id="after">
      <div>Scroll past the pinned hero to verify release behavior.</div>
    </section>

    <script src="./assets/vendor/gsap.min.js"></script>
    <script src="./assets/vendor/ScrollTrigger.min.js"></script>
    <script>
      if (window.gsap && window.ScrollTrigger) {
        gsap.registerPlugin(ScrollTrigger);
      }
    </script>
    <script type="module">
      import * as THREE from "./assets/vendor/three.module.min.js";

      // Constants - moved to top for better organization
      const CONFIG = {
        CAP_VIS_EPS: 0.03,
        CAP_SHRINK_IN: 0.08,
        CAP_SHRINK_OUT: 0.18,
        CAP_SCALE: 1.06,
        BASE_RADIUS: 0.5,
        BOND_RADIUS: 0.14,
        RING_RADIUS: 2.9,
        TARGET_RADIUS: 1.8,
        BULGE_RATIO: 0.35,
        LUT_SAMPLES: 240, // Reduced from 320 for performance
        BASE_COLOR: 0x1a509b,
        // BASE_COLOR: 0x0065b2,
        // BASE_COLOR: 0x1c1a70,
      };

      // === Liquid lag (first-order low-pass) =====================
      const LAG = {
        atom: 6.0, // s^-1   higher = snappier, lower = gooier
        bond: 7.5, // s^-1   bonds can be a bit snappier
        rotation: 1.8, // s^-1   overall group rotation lag
      };

      function dampNumber(cur, target, dt, lambda) {
        const t = 1 - Math.exp(-lambda * dt);
        return cur + (target - cur) * t;
      }
      function dampVec3(v, target, dt, lambda) {
        const t = 1 - Math.exp(-lambda * dt);
        v.x += (target.x - v.x) * t;
        v.y += (target.y - v.y) * t;
        v.z += (target.z - v.z) * t;
        return v;
      }

      // Cached reusable objects
      const tempVectors = {
        v1: new THREE.Vector3(),
        v2: new THREE.Vector3(),
        v3: new THREE.Vector3(),
        dir: new THREE.Vector3(),
        dirN: new THREE.Vector3(),
        tmpNeg: new THREE.Vector3(),
        tmpCw: new THREE.Vector3(),
        tmpOw: new THREE.Vector3(),
        tmpCl: new THREE.Vector3(),
        tmpOl: new THREE.Vector3(),
      };

      const UP = new THREE.Vector3(0, 1, 0);

      // Mobile viewport stability
      (function setVH() {
        const set = () =>
          document.documentElement.style.setProperty(
            "--vh",
            window.innerHeight * 0.01 + "px"
          );
        set();
        addEventListener("resize", set, { passive: true });
        addEventListener("orientationchange", set);
      })();

      const heroEl = document.getElementById("hero");
      const statusEl = document.getElementById("status");
      const posterEl = document.querySelector(".poster");

      {
        const host = heroEl; // mount in #hero
        host.style.position = "relative";
        host.style.background = "transparent"; // let canvas show

        const bg = document.createElement("canvas");
        const g = bg.getContext("2d", { alpha: false });
        bg.style.position = "absolute";
        bg.style.inset = "0";
        bg.style.pointerEvents = "none";
        bg.style.zIndex = "-1"; // behind WebGL
        host.prepend(bg);

        const GOLD = "#ffcf86"; // warm bokeh color
        const GOLD_2 = "#ffc261";
        const BASE = "#050505"; // very dark base

        let W = 0,
          H = 0,
          DPR = 1,
          running = true;
        const M = 26; // number of discs
        const discs = [];

        function resizeBG() {
          DPR = Math.min(window.devicePixelRatio || 1, 1.75);
          W = Math.max(1, host.clientWidth);
          H = Math.max(1, host.clientHeight);
          bg.width = Math.floor(W * DPR);
          bg.height = Math.floor(H * DPR);
          bg.style.width = W + "px";
          bg.style.height = H + "px";
          g.setTransform(DPR, 0, 0, DPR, 0, 0);
        }

        function spawn() {
          discs.length = 0;
          for (let i = 0; i < M; i++) {
            const r = (Math.random() * 80 + 50) * (H / 800);
            const x = Math.random() * W;
            const y = Math.random() * H;
            const s = (0.15 + Math.random() * 0.35) * 0.12; // speed
            const a = Math.random() * Math.PI * 2;
            discs.push({ x, y, r, s, a, phi: Math.random() * 6.28 });
          }
        }

        function grad(x, y, r) {
          const t = g.createRadialGradient(x, y, r * 0.05, x, y, r);
          t.addColorStop(0.0, "rgba(255,230,180,0.85)");
          t.addColorStop(0.45, GOLD);
          t.addColorStop(1.0, "rgba(0,0,0,0)");
          return t;
        }

        function frame(t) {
          if (!running) return;
          g.fillStyle = BASE;
          g.fillRect(0, 0, W, H);

          // gentle angle drift for parallax
          for (const d of discs) {
            d.a += d.s * 0.5;
            d.phi += 0.002;
            d.x += Math.cos(d.a) * d.s * 30.0;
            d.y += Math.sin(d.a) * d.s * 18.0;

            // wrap
            if (d.x < -d.r) d.x = W + d.r;
            if (d.x > W + d.r) d.x = -d.r;
            if (d.y < -d.r) d.y = H + d.r;
            if (d.y > H + d.r) d.y = -d.r;

            // draw
            g.globalCompositeOperation = "lighter";
            g.fillStyle = grad(d.x, d.y, d.r);
            g.beginPath();
            g.arc(d.x, d.y, d.r, 0, Math.PI * 2);
            g.fill();

            // soft hot-core accent
            g.globalCompositeOperation = "screen";
            g.fillStyle = GOLD_2;
            g.globalAlpha = 0.06;
            g.beginPath();
            g.arc(
              d.x,
              d.y,
              d.r * 0.35 * (1 + 0.2 * Math.sin(d.phi)),
              0,
              Math.PI * 2
            );
            g.fill();
            g.globalAlpha = 1;
          }

          // return to normal for next frame
          g.globalCompositeOperation = "source-over";
          requestAnimationFrame(frame);
        }

        resizeBG();
        spawn();
        requestAnimationFrame(frame);
        addEventListener("resize", () => {
          resizeBG();
          spawn();
        });

        document.addEventListener("visibilitychange", () => {
          running = !document.hidden;
          if (running) requestAnimationFrame(frame);
        });
      }

      let renderer, scene, camera, molecule, rafId;
      let bonds = [];
      let atoms = [];
      let center;

      // Geometry cache
      let atomGeo, halfGeo, capGeo;

      // Material cache
      let atomMat, bondMat;

      try {
        // Renderer setup
        renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: false,
          powerPreference: "high-performance",
        });

        const isCoarse = matchMedia("(pointer: coarse)").matches;
        const dprCap = isCoarse ? 1.75 : 2.0;
        renderer.setPixelRatio(Math.min(devicePixelRatio || 1, dprCap));
        renderer.setSize(heroEl.clientWidth, heroEl.clientHeight, false);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        renderer.physicallyCorrectLights = true;
        renderer.sortObjects = true;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.setClearColor(0x000000, 0);
        heroEl.prepend(renderer.domElement);

        // Camera positioning function
        function updateCameraForViewport() {
          const w = window.innerWidth;
          let z = 8.0;
          if (w <= 1280) z = 8.4;
          if (w <= 900) z = 8.8;
          if (w <= 600) z = 9.2;
          if (w <= 420) z = 9.6;
          camera.position.z = z;
          camera.updateProjectionMatrix();
        }

        // Scene setup
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          35,
          heroEl.clientWidth / heroEl.clientHeight,
          0.1,
          100
        );
        camera.position.set(0, 0, 8);

        // Lighting setup
        const key = new THREE.DirectionalLight(0xffffff, 2.75);
        key.position.set(20.2, 30.0, 40.0);
        const rim = new THREE.DirectionalLight(0xaecbff, 3.38);
        rim.position.set(-3.0, 1.2, -2.2);
        const amb = new THREE.AmbientLight(0xffffff, 0.08);
        scene.add(key, rim, amb);

        // Environment setup
        const pmrem = new THREE.PMREMGenerator(renderer);
        pmrem.compileEquirectangularShader();

        const envScene = new THREE.Scene();
        const room = new THREE.Mesh(
          new THREE.BoxGeometry(10, 10, 10),
          new THREE.MeshBasicMaterial({ color: 0x0a2746, side: THREE.BackSide })
        );
        envScene.add(room);

        // Environment panels
        const panelConfigs = [
          // x,   y,   z,   rx,  ry,              w,   h,     hexColor,  intensity
          [-2.2, 2.1, -3.0, 0.0, 0.0, 3.2, 2.2, 0xfff0d6, 2.9], // warm keybox
          [3.0, -1.0, 2.2, 0.0, Math.PI / 2, 2.2, 1.7, 0xffffff, 2.2], // neutral fill
          [-3.2, -2.0, 1.0, 0.0, -Math.PI / 2, 1.6, 2.3, 0xdbe8ff, 1.7], // cool rim
        ];

        panelConfigs.forEach(([x, y, z, rx, ry, w, h, hex, inten]) => {
          const m = new THREE.Mesh(
            new THREE.PlaneGeometry(w, h),
            new THREE.MeshBasicMaterial({ color: hex })
          );
          m.position.set(x, y, z);
          m.rotation.set(rx, ry, 0);
          m.material.color.multiplyScalar(inten);
          envScene.add(m);
        });

        // Material setup
        atomMat = new THREE.MeshPhysicalMaterial({
          color: CONFIG.BASE_COLOR,
          roughness: 0.95,
          metalness: 0.3,
          clearcoat: 0.0,
          clearcoatRoughness: 0.02,
          transmission: 0.5,
          ior: 3.1,
          thickness: 0.3,
          attenuationColor: new THREE.Color(CONFIG.BASE_COLOR),
          attenuationDistance: 1.6,
          envMapIntensity: 1.46,
          opacity: 1,
          transparent: true,
        });

        bondMat = atomMat.clone();
        bondMat.transmission = 0.82;
        bondMat.thickness = 0.42;
        bondMat.envMapIntensity = 1.25;

        // Geometry setup - create once and reuse
        atomGeo = new THREE.SphereGeometry(CONFIG.BASE_RADIUS, 48, 48);
        halfGeo = new THREE.CylinderGeometry(
          CONFIG.BOND_RADIUS,
          CONFIG.BOND_RADIUS,
          1,
          24
        );
        halfGeo.translate(0, 0.5, 0);
        capGeo = new THREE.SphereGeometry(CONFIG.BOND_RADIUS * 1.15, 24, 18);

        // Molecule structure
        molecule = new THREE.Group();
        scene.add(molecule);

        const masterSurface = new THREE.Group();
        molecule.add(masterSurface);

        const centerGroup = new THREE.Group();
        const ringGroup = new THREE.Group();
        masterSurface.add(centerGroup, ringGroup);
        masterSurface.rotation.set(Math.PI / 1.5, -0.2, 0.0);
        masterSurface.userData.rotGoal = {
          x: masterSurface.rotation.x,
          y: masterSurface.rotation.y,
          z: masterSurface.rotation.z,
        };

        // Central atom
        center = new THREE.Mesh(atomGeo, atomMat);
        center.position.set(0, 0, 0);
        center.scale.setScalar(1);
        centerGroup.add(center);
        center.renderOrder = 0;

        // Outer atoms positions
        const baseAngle = Math.PI / 2;
        const step = (2 * Math.PI) / 5;

        const startRing = Array.from({ length: 5 }, (_, i) => {
          const ang = baseAngle - i * step;
          return new THREE.Vector3(
            Math.cos(ang) * CONFIG.RING_RADIUS,
            Math.sin(ang) * CONFIG.RING_RADIUS,
            0
          );
        });

        // Create atoms
        atoms = Array.from({ length: 5 }, (_, i) => {
          const m = new THREE.Mesh(atomGeo, atomMat);
          m.position.copy(startRing[i]);
          m.scale.setScalar(1.2 + Math.random() * 0.45);
          ringGroup.add(m);
          m.renderOrder = 2;
          return m;
        });

        const startPositions = atoms.map((m) => m.position.clone());

        atoms.forEach((m) => {
          m.userData.goal = m.position.clone();
        });

        // Target positions
        const R = CONFIG.TARGET_RADIUS;
        const targets = [
          new THREE.Vector3(0.0, 0.0, R),
          new THREE.Vector3(0.0, 0.0, -R),
          new THREE.Vector3(0.0, R, 0.0),
          new THREE.Vector3(
            R * Math.cos(-Math.PI / 6),
            R * Math.sin(-Math.PI / 6),
            0.0
          ),
          new THREE.Vector3(
            R * Math.cos((7 * Math.PI) / 6),
            R * Math.sin((7 * Math.PI) / 6),
            0.0
          ),
        ];

        function buildSphericalArcSampler(p0, p1) {
          // start/end directions + radii
          const s = p0.clone();
          const r0 = s.length();
          s.normalize();
          const e = p1.clone();
          const r1 = e.length();
          e.normalize();

          // rotation axis & angle between s and e
          let axis = new THREE.Vector3().crossVectors(s, e);
          const sinΩ = axis.length();
          const cosΩ = THREE.MathUtils.clamp(s.dot(e), -1, 1);
          let Ω = Math.atan2(sinΩ, cosΩ);

          if (sinΩ < 1e-6) {
            // parallel or antiparallel
            if (cosΩ > 0.999999) {
              // identical direction: only radial change
              return (u) =>
                s.clone().multiplyScalar(THREE.MathUtils.lerp(r0, r1, u));
            } else {
              // 180° apart — pick any ortho axis
              axis = (
                Math.abs(s.x) < 0.9
                  ? new THREE.Vector3(1, 0, 0)
                  : new THREE.Vector3(0, 1, 0)
              )
                .cross(s)
                .normalize();
              Ω = Math.PI;
            }
          } else {
            axis.normalize();
          }

          // sample along arc; linear radial blend (can swap to smooth if desired)
          return (u) => {
            const dir = s
              .clone()
              .applyAxisAngle(axis, u * Ω)
              .normalize();
            const r = THREE.MathUtils.lerp(r0, r1, u);
            return dir.multiplyScalar(r);
          };
        }

        // optional: arc-length LUT for steadier velocity
        function buildArcLUT(sampleFn, samples = CONFIG.LUT_SAMPLES) {
          const len = new Float32Array(samples + 1);
          let prev = sampleFn(0),
            acc = 0;
          for (let i = 1; i <= samples; i++) {
            const p = sampleFn(i / samples);
            acc += p.distanceTo(prev);
            len[i] = acc;
            prev = p;
          }
          return { len, total: acc };
        }
        function uFromS(lut, s01) {
          const target = s01 * lut.total;
          let lo = 0,
            hi = lut.len.length - 1;
          while (lo < hi) {
            const mid = (lo + hi) >> 1;
            lut.len[mid] < target ? (lo = mid + 1) : (hi = mid);
          }
          const i = Math.max(1, lo);
          const l0 = lut.len[i - 1],
            l1 = lut.len[i];
          const f = (target - l0) / Math.max(1e-6, l1 - l0);
          return (i - 1 + f) / (lut.len.length - 1);
        }

        function moveAlongSphericalArc(atomIdx, p0, p1, tl, dur, at) {
          const sampler = buildSphericalArcSampler(p0, p1);
          const lut = buildArcLUT(sampler);
          const proxy = { s: 0 };
          tl.to(
            proxy,
            {
              s: 1,
              duration: dur,
              ease: "power1.inOut", // keep your global feel; set "none" for uniform angular speed
              onUpdate: () => {
                const u = uFromS(lut, proxy.s);
                atoms[atomIdx].userData.goal.copy(sampler(u));
              },
            },
            at
          );
        }

        // Optimized elliptical via calculation
        function createEllipticalVia(
          startPos,
          targetPos,
          centerPos = new THREE.Vector3(0, 0, 0)
        ) {
          const { v1: toStart, v2: toTarget, v3: midpoint } = tempVectors;

          toStart.subVectors(startPos, centerPos);
          toTarget.subVectors(targetPos, centerPos);
          midpoint.addVectors(startPos, targetPos).multiplyScalar(0.5);

          const chord = tempVectors.dir.subVectors(targetPos, startPos);
          const chordLength = chord.length();

          const orbitalNormal = toStart.clone().cross(toTarget).normalize();
          if (orbitalNormal.length() < 0.001) {
            orbitalNormal.set(0, 0, 1);
          }

          let bulgeDirection = orbitalNormal.clone().cross(chord).normalize();
          const midToCenter = tempVectors.v1.subVectors(centerPos, midpoint);
          if (bulgeDirection.dot(midToCenter) > 0) {
            bulgeDirection.multiplyScalar(-1);
          }

          const bulgeAmount = chordLength * CONFIG.BULGE_RATIO;
          return midpoint
            .clone()
            .add(bulgeDirection.multiplyScalar(bulgeAmount));
        }

        const centerWorldPos = new THREE.Vector3(0, 0, 0);
        const vias = atoms.map((_, i) =>
          createEllipticalVia(startPositions[i], targets[i], centerWorldPos)
        );

        // Optimized Bezier LUT with reduced samples
        function buildSmoothBezierLUT(
          p0,
          p1,
          p2,
          samples = CONFIG.LUT_SAMPLES
        ) {
          const pts = new Array(samples + 1);
          const len = new Float32Array(samples + 1);
          let acc = 0;

          for (let i = 0; i <= samples; i++) {
            let t = i / samples;
            t = t < 0.5 ? 2 * t * t : 1 - 2 * (1 - t) * (1 - t);

            const it = 1 - t;
            const x = it * it * p0.x + 2 * it * t * p1.x + t * t * p2.x;
            const y = it * it * p0.y + 2 * it * t * p1.y + t * t * p2.y;
            const z = it * it * p0.z + 2 * it * t * p1.z + t * t * p2.z;

            pts[i] = new THREE.Vector3(x, y, z);
            if (i > 0) {
              acc += pts[i].distanceTo(pts[i - 1]);
            }
            len[i] = acc;
          }

          return { pts, len, total: acc };
        }

        function tFromS(lut, s) {
          const target = s * lut.total;
          let lo = 0,
            hi = lut.len.length - 1;
          while (lo < hi) {
            const mid = (lo + hi) >> 1;
            lut.len[mid] < target ? (lo = mid + 1) : (hi = mid);
          }
          const i = Math.max(1, lo);
          const l0 = lut.len[i - 1],
            l1 = lut.len[i];
          const f = (target - l0) / Math.max(1e-6, l1 - l0);
          return (i - 1 + f) / (lut.len.length - 1);
        }

        function moveAlongSmoothQuadratic(atomIdx, p0, p1, p2, tl, dur, at) {
          const lut = buildSmoothBezierLUT(p0, p1, p2);
          const proxy = { s: 0 };

          tl.to(
            proxy,
            {
              s: 1,
              duration: dur,
              ease: "power1.inOut",
              onUpdate: () => {
                const t = tFromS(lut, proxy.s);
                const it = 1 - t;
                const x = it * it * p0.x + 2 * it * t * p1.x + t * t * p2.x;
                const y = it * it * p0.y + 2 * it * t * p1.y + t * t * p2.y;
                const z = it * it * p0.z + 2 * it * t * p1.z + t * t * p2.z;
                atoms[atomIdx].position.set(x, y, z);
              },
            },
            at
          );
        }

        // Bond creation
        function createCenterBond(outerIdx) {
          const aHalf = new THREE.Mesh(halfGeo, bondMat);
          const bHalf = new THREE.Mesh(halfGeo, bondMat);
          aHalf.visible = bHalf.visible = false;
          molecule.add(aHalf, bHalf);
          aHalf.renderOrder = 1;
          bHalf.renderOrder = 1;

          const capC = new THREE.Mesh(capGeo, bondMat);
          const capO = new THREE.Mesh(capGeo, bondMat);
          capC.visible = capO.visible = false;
          molecule.add(capC, capO);
          capC.renderOrder = 1;
          capO.renderOrder = 1;

          const pair = {
            a: aHalf,
            b: bHalf,
            capA: capC,
            capB: capO,
            growth: 0,
            growthGoal: 0,
            outerIdx,
            oneSided: true,
          };
          bonds.push(pair);
          return pair;
        }

        // Create bonds
        for (let i = 0; i < 5; i++) {
          createCenterBond(i);
        }

        // Optimized bond positioning
        function positionCenterBond(pair) {
          const {
            tmpCw,
            tmpOw,
            tmpCl,
            tmpOl,
            dir,
            dirN,
            v1: tmpV1,
            v2: tmpV2,
            tmpNeg,
          } = tempVectors;

          center.getWorldPosition(tmpCw);
          atoms[pair.outerIdx].getWorldPosition(tmpOw);

          tmpCl.copy(tmpCw);
          molecule.worldToLocal(tmpCl);
          tmpOl.copy(tmpOw);
          molecule.worldToLocal(tmpOl);

          dir.subVectors(tmpOl, tmpCl);
          const centerDist = dir.length();
          const g = pair.growth;
          const show = g > CONFIG.CAP_VIS_EPS;

          const t = Math.min(
            Math.max(
              (g - CONFIG.CAP_SHRINK_IN) /
                (CONFIG.CAP_SHRINK_OUT - CONFIG.CAP_SHRINK_IN),
              0
            ),
            1
          );
          const s = CONFIG.CAP_SCALE * t;
          pair.capA.scale.setScalar(s);
          pair.capB.scale.setScalar(s);

          const rC = CONFIG.BASE_RADIUS * center.scale.x;
          const rO = CONFIG.BASE_RADIUS * atoms[pair.outerIdx].scale.x;
          const coreLen = Math.max(0, centerDist - (rC + rO));
          const len = coreLen * g;
          const visible = show && len > 1e-6;

          dirN.copy(dir).normalize();

          // One-sided growth optimization
          pair.a.visible = false;
          pair.b.visible = visible;

          if (visible) {
            pair.b.position
              .copy(tmpOl)
              .add(tmpV2.copy(dirN).multiplyScalar(-rO));
            tmpNeg.copy(dirN).multiplyScalar(-1);
            pair.b.quaternion.setFromUnitVectors(UP, tmpNeg);
            pair.b.scale.set(1, len, 1);
          }

          const showCapOuter = g > 0.001;
          const showCapCenter = g > 0.95;

          pair.capB.visible = showCapOuter;
          if (showCapOuter) {
            pair.capB.position
              .copy(tmpOl)
              .add(tmpV2.copy(dirN).multiplyScalar(-rO));
            pair.capB.scale.setScalar(s);
          }

          pair.capA.visible = showCapCenter;
          if (showCapCenter) {
            pair.capA.position
              .copy(tmpCl)
              .add(tmpV1.copy(dirN).multiplyScalar(rC));
            pair.capA.scale.setScalar(CONFIG.CAP_SCALE);
          }
        }

        // Enhanced render loop with continuous motion
        let time = 0;
        let isScrollComplete = false;
        let isFinalized = false;
        let enableFinalMotion = false;
        let finalBlend = 0;
        const clock = new THREE.Clock();

        function render() {
          const dt = clock.getDelta();
          time += 0.008; // Control speed of continuous motion

          // 1) viscous group rotation
          if (masterSurface.userData.rotGoal) {
            const g = masterSurface.userData.rotGoal;
            masterSurface.rotation.x = dampNumber(
              masterSurface.rotation.x,
              g.x,
              dt,
              LAG.rotation
            );
            masterSurface.rotation.y = dampNumber(
              masterSurface.rotation.y,
              g.y,
              dt,
              LAG.rotation
            );
            masterSurface.rotation.z = dampNumber(
              masterSurface.rotation.z,
              g.z,
              dt,
              LAG.rotation
            );
          }

          // 2) viscous atom following
          for (let i = 0; i < atoms.length; i++) {
            const a = atoms[i];
            const goal = a.userData.goal || a.position;
            dampVec3(a.position, goal, dt, LAG.atom);
          }

          // 3) viscous bond growth
          for (const pair of bonds) {
            pair.growth = dampNumber(
              pair.growth,
              pair.growthGoal ?? pair.growth,
              dt,
              LAG.bond
            );
          }

          // Apply continuous motion only after scroll animation completes
          if (enableFinalMotion || finalBlend > 0) {
            const spinMix = enableFinalMotion ? 1 : finalBlend;

            // additive, so it won't fight GSAP's masterSurface rotation
            molecule.rotation.y += 0.0025 * spinMix;
            molecule.rotation.x += Math.sin(time * 0.8) * 0.0012 * spinMix;
            molecule.rotation.z += Math.cos(time * 0.6) * 0.0008 * spinMix;

            // breathing (kept as-is)
            atoms.forEach((atom, i) => {
              const offset = i * 0.8;
              const vibration = Math.sin(time * 1.2 + offset) * 0.002 * spinMix;
              const baseScale = atom.userData.baseScale || atom.scale.x;
              atom.scale.setScalar(baseScale + vibration);
            });
            const centerBreathing = Math.sin(time * 0.9) * 0.003 * spinMix;
            const centerBaseScale = center.userData.baseScale || center.scale.x;
            center.scale.setScalar(centerBaseScale + centerBreathing);
          }

          scene.updateMatrixWorld(true);
          bonds.forEach(positionCenterBond);
          renderer.render(scene, camera);
          rafId = requestAnimationFrame(render);
        }
        rafId = requestAnimationFrame(render);

        // Resize handling
        let resizeRAF;
        const onResize = () => {
          const rect = heroEl.getBoundingClientRect();
          const w = Math.max(1, Math.floor(rect.width));
          const h = Math.max(1, Math.floor(rect.height));

          const isCoarse = matchMedia("(pointer: coarse)").matches;
          const dprCap = isCoarse ? 1.75 : 2.0;
          const nextDpr = Math.min(window.devicePixelRatio || 1, dprCap);
          if (renderer.getPixelRatio() !== nextDpr) {
            renderer.setPixelRatio(nextDpr);
          }

          camera.aspect = w / h;
          camera.updateProjectionMatrix();
          renderer.setSize(w, h, false);
          updateCameraForViewport();

          if (window.ScrollTrigger) {
            cancelAnimationFrame(resizeRAF);
            resizeRAF = requestAnimationFrame(() => ScrollTrigger.refresh());
          }
        };

        addEventListener("resize", onResize, { passive: true });
        addEventListener("orientationchange", onResize);
        addEventListener(
          "pageshow",
          (e) => {
            if (e.persisted) onResize();
          },
          { passive: true }
        );
        onResize();

        // GSAP Timeline
        if (window.gsap && window.ScrollTrigger) {
          const PREFERS_REDUCED = window.matchMedia(
            "(prefers-reduced-motion: reduce)"
          ).matches;

          updateCameraForViewport();

          function finalizeStatic() {
            atoms.forEach((m, i) => {
              m.position.copy(targets[i]);
              // Store base scale for breathing animation
              m.userData.baseScale = m.scale.x;
            });
            bonds.forEach((pair) => {
              pair.growth = 1;
              if (pair.a) pair.a.visible = false;
              if (pair.b) pair.b.visible = true;
              if (pair.capA) pair.capA.visible = true;
              if (pair.capB) pair.capB.visible = true;
              positionCenterBond(pair);
            });

            // Store final rotation and enable continuous motion
            masterSurface.userData.finalRotation = {
              x: masterSurface.rotation.x,
              y: masterSurface.rotation.y,
              z: masterSurface.rotation.z,
            };
            center.userData.baseScale = center.scale.x;
            isScrollComplete = true;

            renderer.render(scene, camera);
            gsap.set("#copy1", { opacity: 0, y: -10 });
            gsap.set("#copy2", { opacity: 1, y: 0 });
          }

          if (PREFERS_REDUCED) {
            finalizeStatic();
            if (rafId) {
              cancelAnimationFrame(rafId);
              rafId = 0;
            }
          } else {
            gsap.ticker.lagSmoothing(0);
            const tl = gsap.timeline({
              defaults: { ease: "none" },
              scrollTrigger: {
                id: "heroST",
                trigger: heroEl,
                start: "top top",
                end: "+=180%",
                scrub: 1.0,
                pin: true,
                anticipatePin: 1,
                invalidateOnRefresh: true,

                onUpdate: (self) => {
                  // NEW — ramp up pre-spin from 97%→100% while still pinned
                  if (self.direction > 0) {
                    finalBlend = gsap.utils.clamp(
                      0,
                      1,
                      (self.progress - 0.97) / 0.03
                    );
                  } else {
                    finalBlend = 0; // kill pre-spin on upward scrub so rollback feels clean
                  }

                  if (!isFinalized && self.progress >= 0.999) {
                    masterSurface.userData.finalRotation = {
                      x: masterSurface.rotation.x,
                      y: masterSurface.rotation.y,
                      z: masterSurface.rotation.z,
                    };
                    atoms.forEach((a) => (a.userData.baseScale = a.scale.x));
                    center.userData.baseScale = center.scale.x;

                    isScrollComplete = true;
                    isFinalized = true;
                  }
                  // enable full free motion only once unpinned
                  enableFinalMotion = isFinalized && !self.isActive;
                },

                onEnter: () => {
                  if (!rafId) rafId = requestAnimationFrame(render);
                  finalBlend = 0; // reset pre-spin when re-entering
                  enableFinalMotion = false;
                },
                onEnterBack: () => {
                  if (!rafId) rafId = requestAnimationFrame(render);
                  finalBlend = 0;
                  enableFinalMotion = false;
                },
                onLeave: () => {
                  if (!isFinalized) {
                    if (rafId) {
                      cancelAnimationFrame(rafId);
                      rafId = 0;
                    }
                  } else {
                    // immediately switch from pre-spin to full free motion after release
                    enableFinalMotion = true;
                    finalBlend = 0;
                  }
                },
                onLeaveBack: () => {
                  if (!isFinalized && rafId) {
                    cancelAnimationFrame(rafId);
                    rafId = 0;
                  }
                  enableFinalMotion = false;
                  finalBlend = 0;
                },
              },
            });

            tl.set("#copy1", { opacity: 0, y: 12 });
            tl.set("#copy2", { opacity: 0, y: 12 });

            tl.to(
              "#copy1",
              { opacity: 1, y: 0, duration: 0.12, ease: "power2.out" },
              0.22
            );
            tl.to(
              "#copy1",
              { opacity: 0, y: -10, duration: 0.12, ease: "power1.out" },
              0.78
            );
            tl.to(
              "#copy2",
              { opacity: 1, y: 0, duration: 0.18, ease: "power2.out" },
              0.82
            );

            const yawTurn = Math.PI * 2;
            tl.to(
              masterSurface.userData.rotGoal,
              { y: "+=" + yawTurn, duration: 1 },
              0
            );
            tl.to(
              masterSurface.userData.rotGoal,
              { x: "+=0.28", z: "-=0.22", duration: 0.5, ease: "sine.inOut" },
              0
            );
            tl.to(
              masterSurface.userData.rotGoal,
              { x: "-=0.28", z: "+=0.22", duration: 0.5, ease: "sine.inOut" },
              0.5
            );

            const beat = 1 / 5;
            const moveDur = beat * 0.98;

            // Movement animations
            for (let i = 0; i < 5; i++) {
              moveAlongSphericalArc(
                i,
                startPositions[i],
                targets[i],
                tl,
                moveDur,
                i * beat
              );
            }

            // Bond growth animations
            bonds.forEach((bond, i) => {
              tl.to(
                bond,
                {
                  growthGoal: 1,
                  duration: beat * 0.9,
                  ease: "power2.out",
                  onStart: () => {
                    bond.b.visible = true;
                    bond.a.visible = false;
                  },
                  onComplete: () => {
                    // Enable continuous motion when the last bond completes
                    if (i === bonds.length - 1) {
                      // Store final rotation state
                      masterSurface.userData.finalRotation = {
                        x: masterSurface.rotation.x,
                        y: masterSurface.rotation.y,
                        z: masterSurface.rotation.z,
                      };

                      // Store base scales for breathing animation
                      atoms.forEach((atom) => {
                        atom.userData.baseScale = atom.scale.x;
                      });
                      center.userData.baseScale = center.scale.x;

                      // Enable continuous motion
                      isScrollComplete = true;
                    }
                  },
                },
                i * beat + beat * 0.7
              );
            });
          }
        }

        // Hide poster and update status
        setTimeout(() => posterEl && posterEl.classList.add("hidden"), 150);
        statusEl.textContent = "Bonds visible + section pinned";
        setTimeout(() => statusEl.remove(), 700);
      } catch (err) {
        console.error("WebGL init failed:", err);
        statusEl.textContent = "WebGL not supported. Showing poster.";
        if (rafId) cancelAnimationFrame(rafId);
      }
    </script>
    <script>
      /*
        Full-background linear-gradient animation mounted inside #hero.
        Palette: #1c1a70 (deep indigo) ↔ #aecbff (soft blue)
      */
      (function () {
        const TARGET = document.getElementById("hero"); // <-- mount here
        if (!TARGET) return;

        const cvs = document.createElement("canvas");
        const ctx = cvs.getContext("2d", { alpha: false });
        cvs.style.position = "absolute";
        cvs.style.inset = "0";
        cvs.style.zIndex = "-1";
        cvs.style.pointerEvents = "none";
        TARGET.style.position = "relative"; // ensure positioning context
        TARGET.style.background = "transparent"; // let gradient show
        TARGET.prepend(cvs);

        const COLOR_A = "#031a30";
        const COLOR_B = "#104068";
        let w = 0,
          h = 0;

        function resize() {
          w = TARGET.clientWidth;
          h = TARGET.clientHeight;
          cvs.width = w;
          cvs.height = h;
        }
        resize();
        window.addEventListener("resize", resize);

        function lerpColor(a, b, t) {
          const ar = parseInt(a.substr(1, 2), 16),
            ag = parseInt(a.substr(3, 2), 16),
            ab = parseInt(a.substr(5, 2), 16);
          const br = parseInt(b.substr(1, 2), 16),
            bg = parseInt(b.substr(3, 2), 16),
            bb = parseInt(b.substr(5, 2), 16);
          const r = Math.round(ar + (br - ar) * t);
          const g = Math.round(ag + (bg - ag) * t);
          const bl = Math.round(ab + (bb - ab) * t);
          return `rgb(${r},${g},${bl})`;
        }

        function draw(t) {
          const time = t * 0.003;
          const angle = time * 0.05;
          const cx = w / 2,
            cy = h / 2;
          const len = Math.sqrt(w * w + h * h) / 2;

          const x0 = cx + Math.cos(angle) * len;
          const y0 = cy + Math.sin(angle) * len;
          const x1 = cx - Math.cos(angle) * len;
          const y1 = cy - Math.sin(angle) * len;

          const grad = ctx.createLinearGradient(x0, y0, x1, y1);
          grad.addColorStop(0, COLOR_A);
          grad.addColorStop(
            0.5 + 0.2 * Math.sin(time * 0.5),
            lerpColor(COLOR_A, COLOR_B, 0.5)
          );
          grad.addColorStop(1, COLOR_B);

          ctx.fillStyle = grad;
          ctx.fillRect(0, 0, w, h);
        }

        function loop(t) {
          draw(t);
          requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);
      })();
    </script>
  </body>
</html>
