<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <meta name="color-scheme" content="light dark" />
    <title>Chematek Hero — Enhanced Interactive Version</title>
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin />
    <style>
      *,*::before,*::after{box-sizing:border-box}
      html,body{height:100%;margin:0}
      body{background:#0a2746;color:#e8eef6;font-family:system-ui,Arial,sans-serif}
      :root{--vh:1vh}
      #hero{
        position:relative;width:100%;
        height:100dvh;height:calc(var(--vh)*100);
        overflow:hidden;overscroll-behavior:contain;
        background:radial-gradient(120% 120% at 30% 20%,#0161ae 0%,#06223d 60%,#002c50 100%);
      }
      #hero canvas{display:block;width:100%;height:100%}
      .poster{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;filter:saturate(.9) brightness(1.05)}
      .poster.hidden{display:none}
      .status{position:absolute;inset:auto 0 1rem 0;text-align:center;font-size:.9rem;opacity:.7;pointer-events:none}
      .copy{
        position:absolute;
        left:8vw; top:18vh;               /* place the headline */
        z-index:20;                       /* above overlay (overlay is z-index:10) */
        max-width:44ch; line-height:1.1; letter-spacing:.02em; text-wrap:balance
      }
      #copy2{ top:calc(18vh + 3.2rem); }   /* subhead below headline */
      #after{min-height:200vh;display:grid;place-items:center;background:linear-gradient(180deg,#051c33 0%,#0b0a46 100%)}
    </style>
  </head>
  <body>
    <section id="hero" aria-label="Hero 3D stage">
      <img class="poster" alt="Molecule hero poster"
        src="data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1200' height='800'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0' y1='0' x2='1' y2='1'%3E%3Cstop stop-color='%230e3969'/%3E%3Cstop offset='1' stop-color='%23051c33'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect fill='url(%23g)' width='1200' height='800'/%3E%3C/svg%3E" />
      <div class="status" id="status">Enhanced interactive version loading…</div>
      <div id="copy1" class="copy"></div>
      <div id="copy2" class="copy"></div>
      <!-- Top-most overlay for soft transparent circles -->
      <canvas id="fx-overlay" style="position:absolute;inset:0;pointer-events:none;z-index:10"></canvas>
    </section>
    <section id="after"><div>Scroll past the pinned hero to verify release behavior.</div></section>

    <script src="./assets/vendor/gsap.min.js"></script>
    <script src="./assets/vendor/ScrollTrigger.min.js"></script>
    <!-- Tiny text splitter (open-source) -->
    <script src="https://cdn.jsdelivr.net/npm/split-type@0.3.4/umd/index.min.js"></script>
    <script>if (window.gsap && window.ScrollTrigger){gsap.registerPlugin(ScrollTrigger);}</script>

    <script type="module">
      import * as THREE from "./assets/vendor/three.module.min.js";

      // --- Viewport unit stability for mobile
      (function setVH(){
        const set=()=>document.documentElement.style.setProperty("--vh", window.innerHeight*0.01 + "px");
        set(); addEventListener("resize", set, {passive:true}); addEventListener("orientationchange", set);
      })();

      const heroEl = document.getElementById("hero");
      const statusEl = document.getElementById("status");
      const posterEl = document.querySelector(".poster");

      // === Bokeh BG (under everything; keep CSS fallback until first paint)
      (function(){
        const host = heroEl;
        const bg = document.createElement("canvas");
        const g = bg.getContext("2d", {alpha:false});
        bg.style.position="absolute"; bg.style.inset="0"; bg.style.pointerEvents="none";
        bg.style.zIndex="-2"; // sits under gradient canvas
        host.prepend(bg);

        const GOLD="#ffcf86", GOLD_2="#ffc261", BASE="#050505";
        let W=0,H=0,DPR=1,running=true, firstPaint=false;
        const M=26, discs=[];

        function resize(){
          DPR = Math.min(window.devicePixelRatio||1, 1.75);
          W = Math.max(1, host.clientWidth); H = Math.max(1, host.clientHeight);
          bg.width = Math.floor(W*DPR); bg.height = Math.floor(H*DPR);
          bg.style.width=W+"px"; bg.style.height=H+"px";
          g.setTransform(DPR,0,0,DPR,0,0);
        }
        function spawn(){
          discs.length=0;
          for(let i=0;i<M;i++){
            const r=(Math.random()*80+50)*(H/800), x=Math.random()*W, y=Math.random()*H;
            const s=(0.15+Math.random()*0.35)*0.12, a=Math.random()*Math.PI*2;
            discs.push({x,y,r,s,a,phi:Math.random()*6.28});
          }
        }
        function grad(x,y,r){const t=g.createRadialGradient(x,y,r*0.05,x,y,r);t.addColorStop(0,"rgba(255,230,180,0.85)");t.addColorStop(0.45,GOLD);t.addColorStop(1,"rgba(0,0,0,0)");return t;}
        function frame(t){
          if(!running) return;
          g.fillStyle=BASE; g.fillRect(0,0,W,H);
          for(const d of discs){
            d.a += d.s*0.5; d.phi += 0.002;
            d.x += Math.cos(d.a)*d.s*30.0; d.y += Math.sin(d.a)*d.s*18.0;
            if(d.x<-d.r) d.x=W+d.r; if(d.x>W+d.r) d.x=-d.r;
            if(d.y<-d.r) d.y=H+d.r; if(d.y>H+d.r) d.y=-d.r;

            g.globalCompositeOperation="lighter"; g.fillStyle=grad(d.x,d.y,d.r);
            g.beginPath(); g.arc(d.x,d.y,d.r,0,Math.PI*2); g.fill();

            g.globalCompositeOperation="screen"; g.fillStyle=GOLD_2; g.globalAlpha=0.06;
            g.beginPath(); g.arc(d.x,d.y,d.r*0.35*(1+0.2*Math.sin(d.phi)),0,Math.PI*2); g.fill();
            g.globalAlpha=1;
          }
          g.globalCompositeOperation="source-over";
          if(!firstPaint){ heroEl.style.background="transparent"; firstPaint=true; }
          requestAnimationFrame(frame);
        }
        resize(); spawn(); requestAnimationFrame(frame);
        addEventListener("resize", ()=>{resize(); spawn();});
        document.addEventListener("visibilitychange", ()=>{running=!document.hidden; if(running) requestAnimationFrame(frame);});
      })();

      // === Three.js scene
      let renderer, scene, camera, molecule, rafId;
      let spinRig; // new parent for stable spin axis
      let bonds = [], atoms = [], center;

      // Materials/geometry
      const CONFIG = {
        BASE_RADIUS: 0.25,
        BOND_RADIUS: 0.07,
        TARGET_RADIUS: 0.9,
        BASE_COLOR: 0x1a509b,
      };

      try{
        renderer = new THREE.WebGLRenderer({antialias:true, alpha:false, powerPreference:"high-performance"});
        const isCoarse = matchMedia("(pointer: coarse)").matches;
        const dprCap = isCoarse ? 1.75 : 2.0;
        renderer.setPixelRatio(Math.min(devicePixelRatio||1, dprCap));
        renderer.setSize(heroEl.clientWidth, heroEl.clientHeight, false);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.setClearColor(0x000000, 0);
        heroEl.prepend(renderer.domElement);

        function updateCameraForViewport(){
          const w = heroEl.clientWidth; // container-based for consistency
          let z = 5.0; if (w<=1280) z=5.4; if (w<=900) z=5.8; if (w<=600) z=6.2; if (w<=420) z=6.6;
          camera.position.z = z; camera.updateProjectionMatrix();
        }

        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(35, heroEl.clientWidth/heroEl.clientHeight, 0.1, 100);
        camera.position.set(0,0,5);

        // Lights
        const key = new THREE.DirectionalLight(0xfff4e6, 2.75); key.position.set(20.2,30.0,40.0);
        const rim = new THREE.DirectionalLight(0xf49a59, 3.38); rim.position.set(-3.0,1.2,-2.2);
        const amb = new THREE.AmbientLight(0xfff4e6, 0.12);
        scene.add(key,rim,amb);

        // Simple env via PMREM from colored planes
        const pmrem = new THREE.PMREMGenerator(renderer); pmrem.compileEquirectangularShader();
        const envScene = new THREE.Scene();
        envScene.add(new THREE.Mesh(new THREE.BoxGeometry(10,10,10), new THREE.MeshBasicMaterial({color:0x0a2746, side:THREE.BackSide})));
        [[-2.2,2.1,-3.0,0,0,3.2,2.2,0xffd6b8,2.9],[3.0,-1.0,2.2,0,Math.PI/2,2.2,1.7,0xfff0e0,2.2],[-3.2,-2.0,1.0,0,-Math.PI/2,1.6,2.3,0xf49a59,1.7]]
          .forEach(([x,y,z,rx,ry,w,h,hex,inten])=>{
            const m=new THREE.Mesh(new THREE.PlaneGeometry(w,h), new THREE.MeshBasicMaterial({color:hex}));
            m.position.set(x,y,z); m.rotation.set(rx,ry,0); m.material.color.multiplyScalar(inten); envScene.add(m);
          });
        const envRT = pmrem.fromScene(envScene, 0.04); scene.environment = envRT.texture;

        // Materials
        const atomMat = new THREE.MeshPhysicalMaterial({
          color: CONFIG.BASE_COLOR, roughness:0.95, metalness:0.3,
          transmission:0.5, ior:3.1, thickness:0.3,
          attenuationColor:new THREE.Color(CONFIG.BASE_COLOR), attenuationDistance:1.6,
          envMapIntensity:1.46, transparent:true
        });
        const bondMat = atomMat.clone(); bondMat.transmission=0.82; bondMat.thickness=0.42; bondMat.envMapIntensity=1.25;

        // Geometries
        const atomGeo = new THREE.SphereGeometry(CONFIG.BASE_RADIUS,48,48);
        const halfGeo = new THREE.CylinderGeometry(CONFIG.BOND_RADIUS, CONFIG.BOND_RADIUS, 1, 24); halfGeo.translate(0,0.5,0);

        // Structure
        // SpinRig -> molecule -> masterSurface
        spinRig = new THREE.Group(); scene.add(spinRig);
        molecule = new THREE.Group(); spinRig.add(molecule);
        const masterSurface = new THREE.Group(); molecule.add(masterSurface);
        const centerGroup = new THREE.Group(); const ringGroup = new THREE.Group();
        masterSurface.add(centerGroup, ringGroup);
        // Aesthetic orientation of the molecule itself (static during the spin pass)
        masterSurface.rotation.set(Math.PI/1.5, -0.2, 0.0);
        masterSurface.userData.rotGoal = {x:masterSurface.rotation.x, y:masterSurface.rotation.y, z:masterSurface.rotation.z};
        // --- Spin axis (NOT local Y). Use a diagonal so it's never colinear with any bond.
        const SPIN_AXIS = new THREE.Vector3(0.61, 0.51, 0.61).normalize();
        // Separate channels: ScrollTrigger animates yawScroll; cursor contributes cursorYaw
        spinRig.userData.yawScroll = 0;     // scroll-driven yaw
        let cursorYaw = 0;                  // raw integrated cursor yaw
        let cursorYawFiltered = 0;          // low-pass filtered cursor yaw
        const _spinQuatTarget = new THREE.Quaternion();
        const _spinQuatCurrent = new THREE.Quaternion(); // current rig quat snapshot

        // Center atom
        center = new THREE.Mesh(atomGeo, atomMat); center.position.set(0,0,0); center.scale.setScalar(1); center.userData.baseScale=center.scale.x;
        centerGroup.add(center); center.renderOrder=0;

        // Target positions (final bonded layout) - smaller molecule
        const R = CONFIG.TARGET_RADIUS * 0.8; // smaller molecule
        const targets = [
          new THREE.Vector3(0,0,R),
          new THREE.Vector3(0,0,-R),
          new THREE.Vector3(0,R,0),
          new THREE.Vector3(R*Math.cos(-Math.PI/6), R*Math.sin(-Math.PI/6), 0),
          new THREE.Vector3(R*Math.cos(7*Math.PI/6), R*Math.sin(7*Math.PI/6), 0),
        ];

        // Outer atoms — place directly at targets (already finished state)
        atoms = Array.from({length:5}, (_,i)=>{
          const m=new THREE.Mesh(atomGeo, atomMat);
          m.position.copy(targets[i]);
          m.scale.setScalar(1.2 + Math.random()*0.45);
          m.userData.baseScale = m.scale.x;
          ringGroup.add(m); m.renderOrder=2; return m;
        });

        // Bonds — fully visible from frame 0 (no growth)
        function createCenterBond(outerIdx){
          const bHalf = new THREE.Mesh(halfGeo, bondMat);
          bHalf.visible = false;            // hidden at start
          molecule.add(bHalf);
          bHalf.renderOrder = 1;
          const pair = { a:null, b:bHalf, outerIdx, growth:0, growthGoal:0 };
          bonds.push(pair);
          return pair;
        }
        for(let i=0;i<5;i++) createCenterBond(i);

        // Bond positioning (straight, extend into atoms)
        const UP = new THREE.Vector3(0,1,0), tmp = {
          cw:new THREE.Vector3(), ow:new THREE.Vector3(),
          cl:new THREE.Vector3(), ol:new THREE.Vector3(),
          dir:new THREE.Vector3(), dirN:new THREE.Vector3(), neg:new THREE.Vector3()
        };
        const overlap = CONFIG.BASE_RADIUS * 0.6;
        function positionCenterBond(pair){
          center.getWorldPosition(tmp.cw); atoms[pair.outerIdx].getWorldPosition(tmp.ow);
          tmp.cl.copy(tmp.cw); molecule.worldToLocal(tmp.cl);
          tmp.ol.copy(tmp.ow); molecule.worldToLocal(tmp.ol);
          tmp.dir.subVectors(tmp.ol,tmp.cl);
          const centerDist = tmp.dir.length();
          const len = Math.max(0, centerDist - overlap*2);
          tmp.dirN.copy(tmp.dir).normalize();
          if (centerDist <= overlap*2 || pair.growth <= 1e-4) { pair.b.visible=false; return; }
          const scaledLen = len * pair.growth;
          if (scaledLen <= 1e-6) { pair.b.visible=false; return; }
          pair.b.visible = true;
          // Position stays anchored at the outer atom side; growth extends inward
          pair.b.position.copy(tmp.ol).add(tmp.dirN.clone().multiplyScalar(-overlap));
          tmp.neg.copy(tmp.dirN).multiplyScalar(-1);
          pair.b.quaternion.setFromUnitVectors(UP, tmp.neg);
          pair.b.scale.set(1, scaledLen, 1);
        }

        // Render loop (no pre-flight; idle breathing after release only)
        let time=0, finalBlend=0, enableFinalMotion=false, isFinalized=false;
        const clock = new THREE.Clock();
        
        // Cursor → spin inertia
        let userSpinVel = 0;                  // radians/sec from pointer
        const sens = 0.001;                  // lower sensitivity → more “laggy” feel
        const friction = 2.8;                 // moderate decay (keeps motion smooth)
        const cursorLagLam = 0.6;              // low-pass lag for cursor-only channel
        let lastMoveTS = 0, lastX = null;
        function onPointerMove(e){
          const x = e.clientX;
          const ts = performance.now();
          if (lastX != null){
            const dtm = Math.max(1, ts - lastMoveTS) / 1000;
            const dx = x - lastX;
            const impulse = (dx * sens) / dtm;
            userSpinVel += impulse;
            // clamp to avoid absurd spins
            userSpinVel = Math.max(-3.0, Math.min(3.0, userSpinVel));
          }
          lastX = x; lastMoveTS = ts;
        }
        heroEl.addEventListener('pointermove', onPointerMove, { passive: true });
        heroEl.addEventListener('pointerleave', ()=>{ lastX = null; }, { passive: true });
        
        function damp(cur,tgt,dt,lam){const k=1-Math.exp(-lam*dt);return cur+(tgt-cur)*k;}
        function render(){
          const dt=clock.getDelta(); time+=0.008;
          // Viscous group rotation
          const g=masterSurface.userData.rotGoal;
          masterSurface.rotation.x = damp(masterSurface.rotation.x, g.x, dt, 1.8);
          masterSurface.rotation.y = damp(masterSurface.rotation.y, g.y, dt, 1.8);
          masterSurface.rotation.z = damp(masterSurface.rotation.z, g.z, dt, 1.8);

          // Cursor inertia: integrate velocity into cursor yaw, apply friction
          if (Math.abs(userSpinVel) > 1e-4){
            cursorYaw += userSpinVel * dt;                          // integrate to yaw
            userSpinVel *= Math.exp(-friction * dt);                // decay velocity
            if (Math.abs(userSpinVel) < 1e-3) userSpinVel = 0;
          }
          // apply extra cursor-only lag
          cursorYawFiltered = (function lp(cur, tgt, dt, lam){
            const k = 1 - Math.exp(-lam * dt);
            return cur + (tgt - cur) * k;
          })(cursorYawFiltered, cursorYaw, dt, cursorLagLam);

          // Apply spin around fixed world axis via quaternion
          const yawTarget = spinRig.userData.yawScroll + cursorYawFiltered;
          _spinQuatTarget.setFromAxisAngle(SPIN_AXIS, yawTarget);
          _spinQuatCurrent.copy(spinRig.quaternion);
          // faster slerp → less scroll lag (cursor lag handled above)
          spinRig.quaternion.slerp(_spinQuatTarget, Math.min(1, dt * 12.0));

          if (enableFinalMotion || finalBlend>0){
            const mix = enableFinalMotion?1:finalBlend;
            molecule.rotation.y += 0.00175*mix;
            molecule.rotation.x += Math.sin(time*0.8)*0.0012*mix;
            molecule.rotation.z += Math.cos(time*0.6)*0.0008*mix;
            atoms.forEach((a,i)=>{const base=a.userData.baseScale; const vib=Math.sin(time*1.2+i*0.8)*0.002*mix; a.scale.setScalar(base+vib);});
            const cb = Math.sin(time*0.9)*0.003*mix; center.scale.setScalar(center.userData.baseScale + cb);
          }

          scene.updateMatrixWorld(true);
          bonds.forEach(positionCenterBond);
          renderer.render(scene,camera);
          rafId=requestAnimationFrame(render);
        }
        rafId=requestAnimationFrame(render);

        // Resize
        function onResize(){
          const rect=heroEl.getBoundingClientRect(); const w=Math.max(1,rect.width|0); const h=Math.max(1,rect.height|0);
          const isCoarse = matchMedia("(pointer: coarse)").matches; const dprCap=isCoarse?1.75:2.0;
          const nextDpr=Math.min(window.devicePixelRatio||1,dprCap);
          if (renderer.getPixelRatio()!==nextDpr) renderer.setPixelRatio(nextDpr);
          camera.aspect=w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h,false); updateCameraForViewport();
          if (window.ScrollTrigger) ScrollTrigger.refresh();
        }
        addEventListener("resize", onResize, {passive:true}); addEventListener("orientationchange", onResize);
        addEventListener("pageshow", e=>{if(e.persisted) onResize();},{passive:true}); onResize();

        // === Spin-only GSAP timeline (exactly one 360°; ease:none)
        if (window.gsap && window.ScrollTrigger){
          gsap.ticker.lagSmoothing(0);
          const tl = gsap.timeline({
            defaults:{ease:"none"},
            scrollTrigger:{
              trigger:heroEl, start:"top top", end:"+=120%", scrub:1.2, pin:true, anticipatePin:1,
              onUpdate:self=>{
                if (!isFinalized && self.progress>=0.999){
                  // capture state; idle motion after unpin
                  center.userData.baseScale = center.scale.x;
                  atoms.forEach(a=>a.userData.baseScale=a.scale.x);
                  isFinalized=true; enableFinalMotion=!self.isActive;
                }
                enableFinalMotion = isFinalized && !self.isActive;
                // a tiny pre-spin just before release to avoid stall
                finalBlend = self.isActive ? Math.max(0,(self.progress-0.97)/0.03) : 0;
              },
              onEnter:()=>{ if(!rafId) rafId=requestAnimationFrame(render); finalBlend=0; enableFinalMotion=false; },
              onEnterBack:()=>{ if(!rafId) rafId=requestAnimationFrame(render); finalBlend=0; enableFinalMotion=false; },
              onLeave:()=>{ enableFinalMotion=true; finalBlend=0; },
              onLeaveBack:()=>{ enableFinalMotion=false; finalBlend=0; }
            }
          });
          const fullTurn = Math.PI * 2;
          const rot1Dur = 0.5;   // atoms-only rotation
          const rot2Dur = 0.5;   // rotation with bond growth

          // Atoms: subtle appear (scale-in) at the very beginning
          atoms.forEach((a)=>{ const b=a.userData.baseScale; a.scale.setScalar(b*0.75); });
          gsap.to(atoms.map(a=>a.scale), {
            x: i => atoms[i].userData.baseScale,
            y: i => atoms[i].userData.baseScale,
            z: i => atoms[i].userData.baseScale,
            duration: 0.18,
            ease: "power2.out",
            stagger: { each: 0.015, from: "center" }
          }, 0.0);

          // Rotation #1 (atoms only)
          tl.call(() => { bonds.forEach(b => { b.growth = 0; }); }, [], 0.0);
          tl.to(spinRig.userData, { yawScroll: `+=${fullTurn}`, duration: rot1Dur, ease: "none" }, 0.0);

          // Kick off bond growth exactly at the boundary between #1 and #2
          // Each bond animates growth 0→1 over the full second rotation (no extra easing on the spin)
          bonds.forEach((bond) => {
            tl.to(bond, { growth: 1, duration: rot2Dur, ease: "power2.out" }, rot1Dur);
          });

          // Rotation #2 (identical spin, bonds now growing)
          tl.to(spinRig.userData, { yawScroll: `+=${fullTurn}`, duration: rot2Dur, ease: "none" }, rot1Dur);
          // keep x/z steady during the spin so start==end pose
        }

        // === Text animation (SplitType UMD) — guarded so CDN issues won't break WebGL
        (function initTextAnim(){
          if (!window.SplitType || !window.gsap) {
            console.warn("SplitType not available; skipping text animation");
            gsap.set(["#copy1", "#copy2"], { opacity: 1, yPercent: 0 });
            return;
          }
          const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
          const headlineEl = document.getElementById('copy1');
          const subheadEl  = document.getElementById('copy2');
          if (headlineEl) headlineEl.textContent = headlineEl.textContent || "Chematek engineered clarity";
          if (subheadEl)  subheadEl.textContent  = subheadEl.textContent  || "Industrial chemistries, simplified.";
          gsap.set([headlineEl, subheadEl], { opacity: 1 });
          const splitHead = new window.SplitType('#copy1', { types: 'words, chars' });
          const splitSub  = new window.SplitType('#copy2', { types: 'words' });
          gsap.set([splitHead.chars, splitSub.words], { opacity: 0, yPercent: 20, willChange: 'transform,opacity' });
          const tlText = gsap.timeline({
            defaults: { ease: 'power2.out' },
            scrollTrigger: { trigger: heroEl, start: 'top top', toggleActions: 'play none none reverse', pin: false }
          });
          if (prefersReduced) {
            tlText.to(splitHead.chars, { opacity: 1, yPercent: 0, duration: 0.2, stagger: 0.006 }, 0.05)
                  .to(splitSub.words,  { opacity: 1, yPercent: 0, duration: 0.2, stagger: 0.02  }, 0.18);
          } else {
            tlText.to(splitHead.chars, { opacity: 1, yPercent: 0, duration: 0.34, stagger: { each: 0.01, from: 'random' } }, 0.05)
                  .to(splitSub.words,  { opacity: 1, yPercent: 0, duration: 0.28, stagger: { each: 0.012, from: 0 } }, 0.22);
          }
        })();

        // === FX overlay: soft transparent circles near atoms ===
        const fxCanvas = document.getElementById('fx-overlay');
        const fxCtx = fxCanvas.getContext('2d');
        let fxW = 0, fxH = 0, fxDPR = 1, fxRunning = true;
        function fxResize(){
          fxDPR = Math.min(window.devicePixelRatio||1, 2);
          fxW = Math.max(1, heroEl.clientWidth);
          fxH = Math.max(1, heroEl.clientHeight);
          fxCanvas.width = Math.floor(fxW * fxDPR);
          fxCanvas.height = Math.floor(fxH * fxDPR);
          fxCanvas.style.width = fxW + 'px';
          fxCanvas.style.height = fxH + 'px';
          fxCtx.setTransform(fxDPR,0,0,fxDPR,0,0);
        }
        fxResize(); addEventListener('resize', fxResize);

        // Project world → screen coords in overlay space
        const _proj = new THREE.Vector3();
        function worldToScreen(v3){
          _proj.copy(v3).project(camera);
          const x = ( _proj.x * 0.5 + 0.5) * fxW;
          const y = (-_proj.y * 0.5 + 0.5) * fxH;
          return { x, y, onScreen: (_proj.z > -1 && _proj.z < 1) };
        }
        // Soft circle blips
        const blips = []; // {x,y,r,alpha,life,fadeIn,fadeOut}
        function spawnBlip(){
          if (atoms.length === 0) return;
          // bias spawn near a random atom (looks more intentional)
          const i = (Math.random()*atoms.length)|0;
          const p = new THREE.Vector3(); atoms[i].getWorldPosition(p);
          const s = worldToScreen(p);
          if (!s.onScreen) return;
          const jitter = Math.min(fxW,fxH) * 0.03;
          const x = s.x + (Math.random()*2-1) * jitter;
          const y = s.y + (Math.random()*2-1) * jitter;
          const r = Math.min(fxW,fxH) * (0.012 + Math.random()*0.04); // different sizes
          blips.push({
            x, y, r,
            alpha: 0,
            life: 1,                 // normalized 1→0
            fadeIn: 0.15 + Math.random()*0.2,
            fadeOut: 0.4 + Math.random()*0.6
          });
        }
        let fxLastTS = 0, blipTimer = 0;
        function renderFX(ts){
          if (!fxRunning){ requestAnimationFrame(renderFX); return; }
          if (!fxLastTS) fxLastTS = ts;
          const dt = (ts - fxLastTS)/1000; fxLastTS = ts;
          blipTimer -= dt;
          if (blipTimer <= 0){ spawnBlip(); blipTimer = 0.8 + Math.random()*1.6; }

          fxCtx.clearRect(0,0,fxW,fxH);
          // Draw blips
          for (let i=blips.length-1;i>=0;i--){
            const b = blips[i];
            // update alpha and life
            if (b.alpha < 1) b.alpha = Math.min(1, b.alpha + dt / b.fadeIn);
            b.life -= dt / b.fadeOut;
            if (b.life <= 0){ blips.splice(i,1); continue; }
            const a = b.alpha * Math.max(0, Math.min(1, b.life));
            fxCtx.save();
            fxCtx.globalAlpha = a * 0.35; // little transparent circles
            // soft fill
            fxCtx.fillStyle = 'rgba(255,220,160,1)';
            fxCtx.beginPath();
            fxCtx.arc(b.x, b.y, b.r, 0, Math.PI*2);
            fxCtx.fill();
            // subtle outline
            fxCtx.globalAlpha = a * 0.6;
            fxCtx.lineWidth = 1;
            fxCtx.strokeStyle = 'rgba(255,230,190,1)';
            fxCtx.stroke();
            fxCtx.restore();
          }

          requestAnimationFrame(renderFX);
        }
        requestAnimationFrame(renderFX);
        document.addEventListener('visibilitychange', ()=>{ fxRunning = !document.hidden; });
        if (window.ScrollTrigger){
          ScrollTrigger.create({
            trigger: heroEl, start: 'top top', end: 'bottom top',
            onEnter: ()=> fxRunning = true,
            onEnterBack: ()=> fxRunning = true,
            onLeave: ()=> fxRunning = true,
            onLeaveBack: ()=> fxRunning = true
          });
        }

        // Hide poster and status
        setTimeout(()=>posterEl && posterEl.classList.add("hidden"),150);
        statusEl.textContent="Enhanced interactive version ready"; setTimeout(()=>statusEl.remove(),600);

      }catch(err){
        console.error("WebGL init failed:", err);
        statusEl.textContent="WebGL not supported. Showing poster.";
        if(rafId) cancelAnimationFrame(rafId);
      }
    </script>

    <script>
      // === Animated gradient BG (above bokeh; keep CSS fallback until first draw; pause on hidden)
      (function(){
        const TARGET=document.getElementById("hero"); if(!TARGET) return;
        const cvs=document.createElement("canvas"); const ctx=cvs.getContext("2d",{alpha:false});
        cvs.style.position="absolute"; cvs.style.inset="0"; cvs.style.zIndex="-1"; cvs.style.pointerEvents="none";
        TARGET.prepend(cvs);
        let w=0,h=0, ready=false, running=true;
        const COLOR_A="#031a30", COLOR_B="#104068";
        function resize(){ w=TARGET.clientWidth; h=TARGET.clientHeight; cvs.width=w; cvs.height=h; }
        function lerpColor(a,b,t){const ar=parseInt(a.substr(1,2),16),ag=parseInt(a.substr(3,2),16),ab=parseInt(a.substr(5,2),16);
          const br=parseInt(b.substr(1,2),16),bg=parseInt(b.substr(3,2),16),bb=parseInt(b.substr(5,2),16);
          const r=Math.round(ar+(br-ar)*t), g=Math.round(ag+(bg-ag)*t), bl=Math.round(ab+(bb-ab)*t); return `rgb(${r},${g},${bl})`; }
        function draw(t){
          const time=t*0.003, angle=time*0.05, cx=w/2, cy=h/2, len=Math.sqrt(w*w+h*h)/2;
          const x0=cx+Math.cos(angle)*len, y0=cy+Math.sin(angle)*len, x1=cx-Math.cos(angle)*len, y1=cy-Math.sin(angle)*len;
          const grad=ctx.createLinearGradient(x0,y0,x1,y1);
          grad.addColorStop(0, COLOR_A);
          grad.addColorStop(0.5+0.2*Math.sin(time*0.5), lerpColor(COLOR_A,COLOR_B,0.5));
          grad.addColorStop(1, COLOR_B);
          ctx.fillStyle=grad; ctx.fillRect(0,0,w,h);
          if(!ready){ TARGET.style.background="transparent"; ready=true; }
        }
        function loop(t){ if(!running){ requestAnimationFrame(loop); return; } draw(t); requestAnimationFrame(loop); }
        resize(); requestAnimationFrame(loop); addEventListener("resize", resize);
        document.addEventListener("visibilitychange", ()=>{running=!document.hidden;});
      })();
    </script>
  </body>
</html>